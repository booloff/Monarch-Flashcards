import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import re
import os
import sys
import shutil
import json
import platform
import random
from difflib import SequenceMatcher
import string
import unicodedata
import time
from PIL import Image, ImageDraw, ImageTk, ImageFilter
import math
from datetime import datetime, date
from itertools import zip_longest
import subprocess
from bidi.algorithm import get_display
import arabic_reshaper
import pygame

pygame.mixer.init()
system = platform.system()
def get_app_data_dir():
    """Get the appropriate app data directory for the current OS"""
    
    if system == "Windows":
        # Use AppData\Local on Windows - more direct path
        base_dir = os.environ.get('LOCALAPPDATA')
        if not base_dir:
            # Fallback to user home if LOCALAPPDATA not available
            base_dir = os.path.expanduser('~')
        return os.path.join(base_dir, "MonarchFlashcards")
    elif system == "Darwin":  # macOS
        # Use ~/Library/Application Support on Mac
        return os.path.join(os.path.expanduser('~'), "Library", "Application Support", "Monarch Flashcards")
    else:  # Linux and others
        # Use ~/.local/share on Linux
        base_dir = os.environ.get('XDG_DATA_HOME', os.path.join(os.path.expanduser('~'), '.local', 'share'))
        return os.path.join(base_dir, "Monarch Flashcards")

# Create data directory and file paths
DATA_DIR = get_app_data_dir()
SETTINGS_FILE = os.path.join(DATA_DIR, "settings.json")
STATS_FILE = os.path.join(DATA_DIR, "stats.json")
FLASHCARDS_DIR = os.path.join(DATA_DIR, "Your decks")
MONARCH_IMAGES_FOLDER = os.path.join(DATA_DIR, "monarch images folder")

# Create other global variables and lists
current_file_path = FLASHCARDS_DIR # Must create a duplicate of FLASHCARDS_DIR for detecting when it changes
tooltip_tracker = False # Variable, tracks if tooltip should be rendered
tooltip_holder = None # This variable turns into a canvas to hold tooltips
tooltip = None
open_in_file_explorer_button = None
open_in_file_explorer_button_frame = None
def create_data_structure():

    """Create the data folder structure if it doesn't exist"""
    try:
        os.makedirs(DATA_DIR, exist_ok=True)
        os.makedirs(FLASHCARDS_DIR, exist_ok=True)
        os.makedirs(MONARCH_IMAGES_FOLDER, exist_ok = True)
        print(f"Data directory created at: {DATA_DIR}")
    except Exception as e:
        print(f"Error creating data directory: {e}")

def load_settings():
    """Load settings from file, return defaults if file doesn't exist"""
    default_settings = {
        "default_study_mode": None,
        "reverse_term_and_definition": False,
        "quick_submit_answer": False,
        "retype_wrong_answer": True,
        "elimination_mode": True,
        "timer": False,
        "timer_length": 3,
        "timer_length_coefficient": 0.2,
        "timer_sound": False,
        "timer_sound_volume": 0.2,
        "show_progress_bars": True,
        "collect_stats": True,
        "random_order": True,
        "must_match_capitalization": False,
        "must_match_punctuation": False,
        "must_match_diacritics": True,
        "allow_typos": False,
        "typo_leniency": 0.86,
        "answer_box_size": 1,
        "font": "Tahoma",
        "font_size": 14,
        "override_correct": "y",
        "override_incorrect": "t",
        "night_mode": False,
    }
    
    try:
        if os.path.exists(SETTINGS_FILE):
            with open(SETTINGS_FILE, 'r', encoding = 'utf-8') as f:
                settings = json.load(f)
                return {**default_settings, **settings}
    except Exception as e:
        print(f"Error loading settings: {e}")
    
    return default_settings

def save_settings(settings):
    """Save settings to file"""
    try:
        with open(SETTINGS_FILE, 'w', encoding = 'utf-8') as f:
            json.dump(settings, f, indent=2)
    except Exception as e:
        print(f"Error saving settings: {e}")

# Initialize data structure
create_data_structure()

# Load settings
app_settings = load_settings()

# Save initial settings to create them
save_settings(app_settings)

def setup_stock_files(path_send, file_name):
    if os.path.exists(path_send):
        print(f"File already found: {file_name}")
        return
    else:
        try:
            base_path = sys._MEIPASS
        except AttributeError:
            # Running from source, not as .exe
            base_path = os.path.abspath(".") # sets base_path to C:\Users\jonat\AppData\Local\Programs\Microsoft VS Code\
        
        full_path = os.path.join(base_path, file_name)
        print(f"Stock file created at {full_path}")
        shutil.copy(full_path, path_send)

cover_graphic = os.path.join(MONARCH_IMAGES_FOLDER, "cover graphic.png")
timer_ended = os.path.join(DATA_DIR, "timer ended.wav")

setup_stock_files(cover_graphic, "cover graphic.png")
setup_stock_files(timer_ended, "timer ended.wav")

# ==== Color palettes for night mode/day mode ====
def update_color_palette():
    global navigation_color_buttons, navigation_color_buttons_hover, navigation_color_backgrounds, navigation_color_text, widgets_color_light, widgets_color_medium, widgets_color_medium_dark, widgets_color_dark, widgets_color_text
    navigation_color_buttons = "#34495e"
    navigation_color_buttons_hover = "#5a6c7d"
    navigation_color_backgrounds = "#2c3e50"
    navigation_color_text = "#eee5De"

    widgets_color_light = "linen"
    widgets_color_medium = "#ebddd1"
    widgets_color_medium_dark = "#b4a88c"
    widgets_color_dark = "#9C885A"
    widgets_color_text = "#2c3e50"

    if app_settings["night_mode"] == True:
        #global navigation_color_buttons, navigation_color_buttons_hover, navigation_color_backgrounds, navigation_color_text, widgets_color_light, widgets_color_medium, widgets_color_medium_dark, widgets_color_dark, widgets_color_text
        navigation_color_buttons = "#1e2e3f"
        navigation_color_buttons_hover = "#2c3e50"
        navigation_color_backgrounds = "#182533"
        navigation_color_text = "#eee5De"

        widgets_color_light = "#575149" # "#797269"
        widgets_color_medium = "#413A31" # "#575149"
        widgets_color_medium_dark = "#332B21" # "#413A31"
        widgets_color_dark = "#292117" # "#332B21"
        widgets_color_text = "#eee5De"
update_color_palette()
root = tk.Tk()
root.title("Monarch Flashcards")
root.geometry("1000x650")  # Set window size to 1000x600 pixels

# SIDEBAR
sidebar = tk.Frame(root, width=150, bg = navigation_color_backgrounds)
sidebar.pack(side="left", fill="y")
sidebar.pack_propagate(False)  # Maintain sidebar width

# MAIN AREA
main_area = tk.Frame(root, bg = "linen")
main_area.pack(side="right", fill="both", expand=True)
main_area.configure(bg = navigation_color_backgrounds)

# Main content area (initially empty)
content_frame = tk.Frame(main_area, bg = widgets_color_light)
content_frame.pack(fill="both", expand=True, padx=10, pady=10)

# CONTENT MANAGEMENT FUNCTIONS

def clear_content():
    """Clear all content from the main area"""
    global content_frame, main_area, open_in_file_explorer_button, open_in_file_explorer_button_frame
    for widget in main_area.winfo_children():
        widget.destroy()

    if open_in_file_explorer_button_frame:
        open_in_file_explorer_button_frame.destroy()
    open_in_file_explorer_button = None
    open_in_file_explorer_button_frame = None


    for widget in sidebar.winfo_children():
        widget.destroy()
    generate_sidebar_buttons()
    
    content_frame = tk.Frame(main_area, bg = widgets_color_light)
    content_frame.pack(fill="both", expand=True, padx=10, pady=10)

# Deck organization system

class FileOrganizer:
    def __init__(self, directory_path):
        self.directory_path = directory_path
        self.max_order = 999999999999  # Large cap for ordering

def repair_order_system(current_file_path): # Step 1 of 3 of file name repair system.
    items = [] # list of file names in current_file_path
    items += os.listdir(current_file_path) # add files in current_file_path to items
    order_list = []  # Use list to store existing order numbers
    needs_order_assigned = [] # list of items that need to be assigned an ordering

    for item in items:
        match = re.match(r'^(-?\d+)[-_ ](.+)$', item)
        if match:
            order_str = match.group(1)
            clean_name = match.group(2)
            order = int(order_str)
            
            # Check for duplicates and find next available order
            while order in order_list:
                order = order + 1
            
            # Add this order to our tracking set
            order_list.append(order)
            
            # Check if the order string needs repair (not 6 digits)
            if len(order_str) != 6 or order != int(order_str):
                old_path = os.path.join(current_file_path, item)
                new_path = os.path.join(current_file_path, f"{order:06d}_{clean_name}")
                os.rename(old_path, new_path)

        else:
            needs_order_assigned.append(item)
    
    if needs_order_assigned:
        auto_assign_order(current_file_path)
    
    return

# def manual_assign_order():
    # implement later
    
def auto_assign_order(current_file_path): # Step 2 of 3 of file name repair system
    items = os.listdir(current_file_path)
    order_list = []
    unordered_items = []
    
    # First pass: collect existing order numbers
    for item in items:
        match = re.match(r'^(-?\d+)[-_ ](.+)$', item)
        if match:
            order = int(match.group(1))
            order_list.append(order)

        else:
            unordered_items.append(item)

    order_list.sort()
    if unordered_items:
        for unordered_item in unordered_items:
            item_path = os.path.join(current_file_path, unordered_item)
            if os.path.isdir(item_path):  # It's a folder
                if order_list:
                    lowest_ordering = order_list[0]
                    new_ordering = lowest_ordering - 1
                else:
                    new_ordering = 0
            elif unordered_item.lower().endswith('.txt' or '.midi' or '.pdf'):  # It's a text, midi, or pdf file
                if order_list:
                    highest_ordering = order_list[-1]
                    new_ordering = highest_ordering + 1
                else:
                    new_ordering = 1

            new_path = os.path.join(current_file_path, f"{new_ordering:06d}_{unordered_item}")
            os.rename(item_path, new_path)
            order_list.append(new_ordering)

    order_list.sort()
    if order_list[0] < 0: # if there's any items indexed with negative numbers
        great_shift(current_file_path)

    return

def great_shift(current_file_path): # Step 3 of 3 of file name repair system. Prevents files from getting prefixed with negative numbers by shifting prefixes forward
    items = os.listdir(current_file_path)
    items.sort()

    for serial_order, item in enumerate(reversed(items)): # must iterate last-to-first to prevent potential over-writes
        fixed_serial_order = len(items) - serial_order - 1 # fixes serial_order which was reversed due to iterating last-to-first
        match = re.match(r'^(-?\d+)[-_ ](.+)$', item) # separate file's indexing prefix with its file name
        if match:
            order_str = match.group(1)
            clean_name = match.group(2)
            order = int(order_str)

            # fixed_serial_order = len(items) - serial_order #

            if order < fixed_serial_order: # if file name is prefixed lower than actual position, changes prefix to match actual position
                old_path = os.path.join(current_file_path, item)
                new_path = os.path.join(current_file_path, f"{fixed_serial_order:06d}_{clean_name}")
                os.rename(old_path, new_path)

def check_for_name_errors(current_file_path):
    items = [] # list of file names in current_file_path
    items += os.listdir(current_file_path) # add files in current_file_path to items
    order_list = [] # list of orderings of items in current_file_path

    needs_repair = False # do the files need to be repaired

    for item in items:
        match = re.match(r'(-?\d{6})[_](.+)$', item)
        if match:
            order_str = match.group(1)
            order = int(order_str)
        
            if order in order_list: # check if there are duplicate indexes
                needs_repair = True
                break  # No need to continue checking
            else:
                order_list.append(order)
        else: # check if there are unindexed or incorrectly indexed items
            needs_repair = True
            break

    if needs_repair:
        repair_order_system(current_file_path)
        items = [] # regenerate items set with corrected file names
        items += os.listdir(current_file_path) # add files back
def choose_create_new():
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    print("Create new! Choose what to create")
    clear_content()
    content_frame.config(bg = widgets_color_medium)

    back_button = tk.Button(content_frame, text = "Back", relief="raised", width = 11, height = 1, padx=4, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: flashcards_clicked(current_file_path))
    back_button.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "nw")
    back_button.bind('<Leave>', lambda event, palette="light": on_default(event, palette))
    back_button.bind('<Enter>', lambda event, palette="light", tooltip_text = "Go back": on_hover(event, palette, tooltip_text))

    create_new_box = tk.Label(content_frame, text="What would you like to create?", width = 30, font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = widgets_color_text, height=1)
    create_new_box.grid(row = 1, column = 0, columnspan = 2, sticky="we", padx=50, pady=(50, 0))

    create_new_deck_button = tk.Button(content_frame, text="Create deck", width = 30, font=(app_settings['font'], app_settings['font_size']), justify="left", bg = navigation_color_buttons, fg = navigation_color_text, height=1, command = lambda path_send = current_file_path: create_new_flashcards(path_send))
    create_new_deck_button.grid(row = 2, column = 0, sticky="we", padx=50, pady=(50, 0))
    create_new_deck_button.bind('<Leave>', lambda event, palette="dark": on_default(event, palette))
    create_new_deck_button.bind('<Enter>', lambda event, palette="dark", tooltip_text = "Create deck": on_hover(event, palette, tooltip_text))

    create_new_folder_button = tk.Button(content_frame, text="Create folder", width = 30, font=(app_settings['font'], app_settings['font_size']), justify="left", bg = navigation_color_buttons, fg = navigation_color_text, height=1, command = lambda path_send = current_file_path: create_new_folder(path_send))
    create_new_folder_button.grid(row = 2, column = 1, sticky="we", padx=50, pady=(50, 0))
    create_new_folder_button.bind('<Leave>', lambda event, palette="dark": on_default(event, palette))
    create_new_folder_button.bind('<Enter>', lambda event, palette="dark", tooltip_text = "Create a folder to organize your decks": on_hover(event, palette, tooltip_text))

def create_new_folder(path_send = current_file_path, edit_mode = False):
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    print(f"Create new flashcard set! Edit mode = {edit_mode}")
    clear_content()
    content_frame.config(bg = widgets_color_medium)

    location_box_string = os.path.relpath(path_send, DATA_DIR)
    original_title = None
    path_save = path_send
    error_box = None

    back_button = tk.Button(content_frame, text = "Back", relief="raised", width = 11, height = 1, padx=4, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: flashcards_clicked(current_file_path))
    back_button.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "nw")
    back_button.bind('<Leave>', lambda event, palette="light": on_default(event, palette))
    back_button.bind('<Enter>', lambda event, palette="light", tooltip_text = "Go back": on_hover(event, palette, tooltip_text))

    title_label = tk.Label(content_frame, text="Folder title", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = widgets_color_text, height=1)
    title_label.grid(row=0, column=0, columnspan = 2, sticky="w", padx=50, pady=(50, 0))

    title_box = tk.Text(content_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, width=70, height=1, relief="sunken")
    title_box.grid(row=1, column=0, columnspan=3, padx=50, pady=(0, 15), sticky="we")

    location_box = tk.Button(content_frame, text=f"Save to: {location_box_string}", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_light, fg = widgets_color_text, command=lambda: path_manager(path_save))
    location_box.grid(row=2, column=0, columnspan=3, padx=50, pady=(0, 15), sticky="nsew")
    location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string}": on_hover(event, "light", tooltip_send))
    location_box.bind("<Leave>", lambda event: on_default(event, "light"))

    save_button = tk.Button(content_frame, text=f"Save folder", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = navigation_color_backgrounds, fg = navigation_color_text, command=lambda: save_folder())
    save_button.grid(row=3, column=0, columnspan = 3, padx=50, pady=(0, 15))
    save_button.bind("<Enter>", lambda event, tooltip_send = "Save folder": on_hover(event, "dark", tooltip_send))
    save_button.bind("<Leave>", lambda event: on_default(event, "dark"))

    if edit_mode == True:
        original_title = os.path.basename(path_send)
        title_box.insert("1.0", str(original_title))

    def save_folder():
        nonlocal path_save, error_box

        title = title_box.get("1.0", "end-1c")
        if title:
            print(f"Title: {title}")

            invalid_chars = r'\/:*?"<>|'

            for char in title:
                if char in invalid_chars:
                    title_label.config(fg = "red", text = """Error: Title can not contain \ / : * ? " < >""")
                    return

        else:
            print("Error: title not found")

            title_label.config(fg = "red", text = "Error: Your folder needs a title!")
            
            return
        
        final_path_save = os.path.join(path_save, title)
        
        #os.makedirs(path_save, exist_ok=True)
        
        #flashcard_file_name = os.path.join(path_save, title)
        error_code = False

        if edit_mode == True:
            # ==== edit mode, rename old folder to new path ====
            print("Saving deck (edit mode)")

            os.rename(path_send, final_path_save)

    
        else:
            # ==== normal mode, create new folder ====
            print("Saving deck (normal mode)")

            os.makedirs(final_path_save, exist_ok=True)
        
        clear_content()
        content_frame.columnconfigure(0, weight = 1)
        content_frame.columnconfigure(1, weight = 1)
        folder_created_label = tk.Label(content_frame, text = "Folder created!", bg = navigation_color_backgrounds, fg = navigation_color_text, font=(app_settings['font'], (app_settings['font_size'] + 4)), padx = 20, pady = 20)
        folder_created_label.grid(row = 0, column = 0, columnspan = 2, padx = 0, pady = (0, 20), sticky = "nsew")

        open_folder_button = tk.Button(content_frame, text = "Open this folder", width = 30, bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), command = lambda path = final_path_save: flashcards_clicked(path))
        open_folder_button.grid(row = 1, column = 0, columnspan = 2, padx = 60, pady = 20, sticky = "we")
        open_folder_button.bind("<Enter>", lambda event, tooltip_send = "Open the newly created folder": on_hover(event, "dark", tooltip_send))
        open_folder_button.bind("<Leave>", lambda event: on_default(event, "dark"))

        create_deck_button = tk.Button(content_frame, text = "Create a deck", width = 30, bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), command = lambda path = path_send: create_new_flashcards(path))
        create_deck_button.grid(row = 2, column = 1, padx = 40, pady = 20, sticky = "we")
        create_deck_button.bind("<Enter>", lambda event, tooltip_send = "Create a deck": on_hover(event, "dark", tooltip_send))
        create_deck_button.bind("<Leave>", lambda event: on_default(event, "dark"))

        create_another_folder_button = tk.Button(content_frame, text = "Create another folder", width = 30, bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), command = lambda path = path_send: create_new_folder(path))
        create_another_folder_button.grid(row = 2, column = 0, padx = 40, pady = 20, sticky = "we")
        create_another_folder_button.bind("<Enter>", lambda event, tooltip_send = "Create another folder": on_hover(event, "dark", tooltip_send))
        create_another_folder_button.bind("<Leave>", lambda event: on_default(event, "dark"))

    def path_manager(folder_path_send = path_save):
        print("Path manager called")

            # Create main frame
        folder_select_frame = tk.Frame(content_frame)
        folder_select_frame.grid(row = 3, column = 0, rowspan = 6, columnspan=3, padx=50, pady=(0, 15), sticky = "nwe")
        folder_select_frame.configure(bg = widgets_color_light)

        for widget in folder_select_frame.winfo_children():
            print(f"Destroying {widget}")
            widget.destroy()

        #folder_select_frame_label = tk.Label
        folder_select_frame_top = tk.Frame(folder_select_frame, bg = navigation_color_backgrounds)
        folder_select_frame_top.pack(side="top", fill = "both", expand = True)

        folder_select_frame_label = tk.Label(folder_select_frame_top, bg = navigation_color_backgrounds, fg = "gray", font=(app_settings['font'], app_settings['font_size']), text = "Choose a file destination")
        folder_select_frame_label.pack(side = "left", fill = "both", expand = True)

        def close_path_manager(path_select = path_save):
            print("Attempt to close location manager menu")
            nonlocal location_box, location_box_string, path_save
            location_box_string = os.path.relpath(path_select, DATA_DIR)
            location_box.config(text = f"Save to: {location_box_string}")
            location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string}": on_hover(event, "light", tooltip_send))
            location_box.bind("<Leave>", lambda event: on_default(event, "light"))
            path_save = path_select
            #nonlocal folder_select_frame
            for menu_item in folder_select_frame.winfo_children():
                print(f"{menu_item}")
                menu_item.destroy()
            folder_select_frame.destroy()
        
            location_box.config(command = lambda: path_manager(path_save))

            configure_main_scroll_region()

        location_box.config(command = lambda: close_path_manager())
        location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string}": on_hover(event, "light", tooltip_send))
        location_box.bind("<Leave>", lambda event: on_default(event, "light"))

        folder_select_frame_exit_button = tk.Button(folder_select_frame_top, bg = navigation_color_backgrounds, fg = "gray", font=(app_settings['font'], app_settings['font_size']), text = "X", command = lambda: close_path_manager())
        folder_select_frame_exit_button.pack(side="right", fill = "both")
        folder_select_frame_exit_button.bind('<Leave>', lambda event, palette="dark": on_default(event, palette))
        folder_select_frame_exit_button.bind('<Enter>', lambda event, palette="dark", tooltip_text = "Exit folder select": on_hover(event, palette, tooltip_text))

        # Create canvas and scrollbar
        folder_select_canvas = tk.Canvas(folder_select_frame, bg = widgets_color_light)
        scrollbar = tk.Scrollbar(folder_select_frame, orient=tk.VERTICAL, command=folder_select_canvas.yview)
        scrollable_frame = tk.Frame(folder_select_canvas, bg = widgets_color_light)

        # Configure canvas scrolling
        folder_select_canvas.configure(yscrollcommand=scrollbar.set)
        folder_select_canvas.bind('<Configure>', lambda e: folder_select_canvas.configure(scrollregion=folder_select_canvas.bbox("all")))

        window_id2 = folder_select_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # check if this breaks
        def configure_scroll_region(event):
            # Update scroll region based on canvas contents
            content_frame.configure(scrollregion=content_frame.bbox("all"))
            
            # Make the frame fill the canvas width
            canvas_width = content_frame.winfo_width()
            content_frame.itemconfig(window_id2, width=canvas_width)

            content_frame.bind('<Configure>', configure_scroll_region)

        #def configure_scroll_region(event):
        #    # Update scroll region based on canvas contents
        #    create_flashcards_canvas.configure(scrollregion=create_flashcards_canvas.bbox("all"))
            
        #    # Make the frame fill the canvas width
        #    canvas_width = create_flashcards_canvas.winfo_width()
        #    create_flashcards_canvas.itemconfig(window_id2, width=canvas_width)

        #    create_flashcards_canvas.bind('<Configure>', configure_scroll_region)

        if system == "Windows" or system =="Darwin":
            print("setup scroll for Windows/Mac")
            def on_mousewheel2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

            root.bind("<MouseWheel>", on_mousewheel2)  # Windows/Mac
        else:
            print("setup scroll for Linux")
            def on_mousewheel_linux_down2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(-1, "units")
                else:
                    print("Could not scroll")

            def on_mousewheel_linux_up2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(1, "units")
                else:
                    print("Could not scroll")

            root.bind("<Button-4>", on_mousewheel_linux_up2)  # Linux
            root.bind("<Button-5>", on_mousewheel_linux_down2)  # Linux

        # Create window inside canvas
        folder_select_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # Pack scrollbar and canvas
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        folder_select_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Now add buttons to scrollable_frame instead of main_frame

        flashcard_master = [] # list to use for creating flashcard buttons
        def generate_folder_buttons(path_select):
            nonlocal location_box, path_save
            path_save = path_select
            print(f"Open folders list: {path_select}")

            folders = [] # list of file names in current_file_path
            folders += os.listdir(path_save) # add files in current_file_path to folders

            folders.sort()

            for widget in scrollable_frame.winfo_children():
                widget.destroy()
            if path_save != FLASHCARDS_DIR:
                folders.insert(0,"Back")

            folder_detected = False

            for item in folders:
                match = re.search(r'(-?\d+)[_ -](.+)', item)
                if match:
                    display_name = match.group(2)
                    display_name_no_ext = os.path.splitext(display_name)[0]  # Remove extension
                else:
                    display_name_no_ext = os.path.splitext(item)[0] # if no match found (unlikely) just display file name

                button_command = None
                button_color_palette = "medium"
                try:
                    full_path = os.path.join(path_save, item)
                except:
                    full_path = path_save
                print(f"Path: {path_save}")
                print(f"Full path: {full_path}")
                if os.path.isdir(full_path):  # Check the full path
                    print(f"Folder detected: {item}")
                    symbol = "  ▶"
                    button_command = lambda path=full_path: close_path_manager(path)
                    button_color_palette = "medium"
                    background = widgets_color_medium
                    foreground = widgets_color_text

                    btn = tk.Button(
                        scrollable_frame,
                        text = f"""{symbol} {display_name_no_ext}""",
                        width=100, 
                        height=1, 
                        font=(app_settings['font'], app_settings['font_size']),
                        anchor="w",
                        relief="flat",
                        bd=0,
                        command=button_command,
                        bg = background, 
                        fg = foreground)
                    btn.pack(pady=1, padx=1)

                    btn.bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))
                    btn.bind('<Enter>', lambda event, palette=button_color_palette, tooltip_text = "Select this folder": on_hover(event, palette, tooltip_text))

                    folder_detected = True

                elif item == "Back":
                    print(f"Back button detected: {item}")
                    symbol = "←"
                    button_command = lambda path = os.path.dirname(path_save): close_path_manager(path) # Go back to last file location
                    button_color_palette = "medium"
                    background = widgets_color_medium
                    foreground = widgets_color_text
            
                    btn = tk.Button(
                        scrollable_frame,
                        text = f"""{symbol} {display_name_no_ext}""",
                        width=100, 
                        height=1, 
                        font=(app_settings['font'], app_settings['font_size']),
                        anchor="w",
                        relief="flat",
                        bd=0,
                        command=button_command,
                        bg = background, 
                        fg = foreground)
                    btn.pack(pady=1, padx=1)

                    btn.bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))
                    btn.bind('<Enter>', lambda event, palette=button_color_palette, tooltip_text = "Go back": on_hover(event, palette, tooltip_text))
        generate_folder_buttons(folder_path_send)


def create_new_flashcards(path_send = current_file_path): # path_send is current_file_path by default || This function also handles editing flashcard decks
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    print("Create new flashcard set!")
    clear_content()

    edit_mode = None
    original_title = None
    flashcard_widgets = {}
    path_save = path_send
    error_box = None
    print(f"path_send: {path_send}")
    #match = re.match(r = "()(flashcards)")

    if path_send.lower().endswith(('.txt', '.midi', '.pdf')):
        print("Fix location box string")
        location_box_string_temp = os.path.dirname(path_send)
        location_box_string = os.path.relpath(location_box_string_temp, DATA_DIR)
    else:
        location_box_string = os.path.relpath(path_send, DATA_DIR)

    location_box_string_no_index = re.sub(r'\d+_', '', location_box_string)

    print(f"Location box string: {location_box_string_no_index}")

    create_flashcards_canvas = tk.Canvas(content_frame, bg = widgets_color_medium)
    create_flashcards_scrollable_frame = tk.Frame(create_flashcards_canvas, bg = widgets_color_light)

    create_flashcards_scrollable_frame.config(bg = widgets_color_medium)
    create_flashcards_scrollable_frame.columnconfigure(0, minsize = 300, weight = 1)
    create_flashcards_scrollable_frame.columnconfigure(1, minsize = 50)
    create_flashcards_scrollable_frame.columnconfigure(2, minsize = 300, weight = 1)

    # Create scrollbar and configure it with canvas
    create_flashcards_scrollbar = tk.Scrollbar(content_frame, orient="vertical", command=create_flashcards_canvas.yview)
    create_flashcards_canvas.configure(yscrollcommand=create_flashcards_scrollbar.set)

    # Pack scrollbar and canvas
    create_flashcards_scrollbar.pack(side="right", fill="y")
    create_flashcards_canvas.pack(side="left", fill="both", expand=True)

    # Create the window inside the canvas and store the window ID
    window_id = create_flashcards_canvas.create_window((0, 0), window=create_flashcards_scrollable_frame, anchor="nw")

    # Configure scroll region and frame width when canvas size changes
    def configure_scroll_region(event):
        # Update scroll region based on canvas contents
        create_flashcards_canvas.configure(scrollregion=create_flashcards_canvas.bbox("all"))
        
        # Make the frame fill the canvas width
        canvas_width = create_flashcards_canvas.winfo_width()
        create_flashcards_canvas.itemconfig(window_id, width=canvas_width)

    create_flashcards_canvas.bind('<Configure>', configure_scroll_region)

    # Also need to update scroll region when frame contents change
    def update_scroll_region():
        create_flashcards_canvas.configure(scrollregion=create_flashcards_canvas.bbox("all"))

    create_flashcards_scrollable_frame.bind('<Configure>', lambda e: update_scroll_region())

    # Mouse wheel scrolling
    def configure_main_scroll_region():
        if system == "Windows" or system == "Darwin":
            print("setup scroll for Windows/Mac")
            def on_mousewheel(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                create_flashcards_scrollable_frame_height = create_flashcards_scrollable_frame.winfo_height()
                create_flashcards_canvas_height = create_flashcards_canvas.winfo_height()

                print(f"Create flashcards scrollable frame height: {create_flashcards_scrollable_frame_height}, Create flashcards canvas height: {create_flashcards_canvas_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if create_flashcards_scrollable_frame_height > create_flashcards_canvas_height:
                    print("attempt to scroll")
                    create_flashcards_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

            root.bind("<MouseWheel>", on_mousewheel)  # Windows/Mac
        else:
            print("setup scroll for Linux")
            def on_mousewheel_linux_down(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                create_flashcards_scrollable_frame_height = create_flashcards_scrollable_frame.winfo_height()
                create_flashcards_canvas_height = create_flashcards_canvas.winfo_height()

                print(f"Create flashcards scrollable frame height: {create_flashcards_scrollable_frame_height}, Create flashcards canvas height: {create_flashcards_canvas_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if create_flashcards_scrollable_frame_height > create_flashcards_canvas_height:
                    print("attempt to scroll")
                    create_flashcards_canvas.yview_scroll(-1, "units")
                else:
                    print("Could not scroll")

            def on_mousewheel_linux_up(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                create_flashcards_scrollable_frame_height = create_flashcards_scrollable_frame.winfo_height()
                create_flashcards_canvas_height = create_flashcards_canvas.winfo_height()

                print(f"Create flashcards scrollable frame height: {create_flashcards_scrollable_frame_height}, Create flashcards canvas height: {create_flashcards_canvas_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if create_flashcards_scrollable_frame_height > create_flashcards_canvas_height:
                    print("attempt to scroll")
                    create_flashcards_canvas.yview_scroll(1, "units")
                else:
                    print("Could not scroll")

            root.bind("<Button-4>", on_mousewheel_linux_up)  # Linux
            root.bind("<Button-5>", on_mousewheel_linux_down)  # Linux
    
    configure_main_scroll_region()

    if path_send.lower().endswith(('.txt', '.midi', '.pdf')): # if editing a pre-existing flashcard set
        edit_mode = True
        original_title = os.path.basename(path_send)

        fix_original_title = re.search(r'(-?\d+)[_ -](.+)', original_title)
        if fix_original_title:
            original_title_bare = fix_original_title.group(2)
            original_title_no_ext = os.path.splitext(original_title_bare)[0]  # Remove extension
        else:
            original_title_no_ext = os.path.splitext(original_title)[0] # if no match found (unlikely) just display file name
        
        with open(path_send, 'r', encoding='utf-8') as file:
            handling = file.readlines() # "handling" contains items in selected flashcard set
            print(f"Opening flashcard set in edit mode: {handling}")
            item_list = handling
        
        path_correction = os.path.dirname(path_send)
        path_save = path_correction

    else:
        item_list = [] # store entries in this list
        edit_mode = False
        original_title = None
        original_title_no_ext = None
    placeholder_active = {}

    print(f"Title: {original_title_no_ext}")

    # ==== Setup widgets ====
    back_button = tk.Button(create_flashcards_scrollable_frame, text = "Back", relief="raised", width = 11, height = 1, padx=4, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: flashcards_clicked(current_file_path))
    back_button.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "nw")
    back_button.bind('<Leave>', lambda event, palette="light": on_default(event, palette))
    back_button.bind('<Enter>', lambda event, palette="light", tooltip_text = "Go back": on_hover(event, palette, tooltip_text))

    title_label = tk.Label(create_flashcards_scrollable_frame, text="Title", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = widgets_color_text, height=1)
    title_label.grid(row=0, column=0, columnspan = 2, sticky="w", padx=50, pady=(50, 0))

    title_box = tk.Text(create_flashcards_scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, width=70, height=1, relief="sunken")
    title_box.grid(row=1, column=0, columnspan=3, padx=50, pady=(0, 15), sticky="we")
    if original_title != None:
        title_box.insert("1.0", str(original_title_no_ext))

    location_box = tk.Button(create_flashcards_scrollable_frame, text=f"Save location: {location_box_string_no_index}", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_light, fg = widgets_color_text, command=lambda: path_manager(path_save))
    location_box.grid(row=2, column=0, columnspan=3, padx=(55), sticky="nsew", pady=(0, 50))
    location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string_no_index}": on_hover(event, "light", tooltip_send))
    location_box.bind("<Leave>", lambda event: on_default(event, "light"))

    #import_box = tk.Button(create_flashcards_scrollable_frame, text="Import", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    #import_box.grid(row=2, column=2, pady=(0, 35))
    #import_box.bind("<Enter>", lambda event, tooltip_send = "Open in file explorer": on_hover(event, "light", tooltip_send))
    #import_box.bind("<Leave>", lambda event: on_default(event, "light"))

    body_frame = tk.Frame(create_flashcards_scrollable_frame, bg = widgets_color_light, )
    body_frame.grid(row = 3, column = 0, columnspan = 3, sticky = "we", pady = 10)
    body_frame.columnconfigure(0, weight = 1)

    save_list_button = tk.Button(create_flashcards_scrollable_frame, font=(app_settings['font'], app_settings['font_size']), text = "Save flashcard set", width = 18, height = 1, bg = navigation_color_buttons, fg = navigation_color_text, command = lambda: save_flashcards())
    save_list_button.grid(row = 5, column = 1, pady = 35)
    save_list_button.bind("<Enter>", lambda event, tooltip_send = f"Save flashcards": on_hover(event, "dark", tooltip_send))
    save_list_button.bind("<Leave>", lambda event: on_default(event, "dark"))
    
    add_new_item_button = tk.Button(create_flashcards_scrollable_frame, font=(app_settings['font'], app_settings['font_size']), text = "Add new term", width = 14, height = 1, bg = widgets_color_light, fg = widgets_color_text, command = lambda: add_new_item())
    add_new_item_button.grid(row = 4, column = 1)
    add_new_item_button.bind("<Enter>", lambda event, tooltip_send = f"Add new item": on_hover(event, "light", tooltip_send))
    add_new_item_button.bind("<Leave>", lambda event: on_default(event, "light"))

    """
    dummy_item_1 = (("dummy prompt"), ("dummy answer"))
    dummy_item_2 = (("second dummy prompt"), ("second dummy answer"))
    dummy_item_3 = (("third dummy prompt"), ("third dummy answer"))
    item_list.append(dummy_item_1)
    item_list.append(dummy_item_2)
    item_list.append(dummy_item_3)
    """

    print(f"Item list: {item_list}")

    def remove_placeholder_text(widget, is_prompt_widget):
        contents = widget.get("1.0", "end-1c")
        widget_string = str(widget)
        if placeholder_active[widget_string] == True:
            print("attempt to remove placeholder text")
            widget.delete("1.0", "end-1c")
            widget.config(fg = widgets_color_text)
            placeholder_active[widget_string] = False

    def add_placeholder_text(widget, is_prompt_widget):
        contents = widget.get("1.0", "end-1c")
        widget_string = str(widget)
        if contents == "":
            widget.config(fg = "gray")
            placeholder_active[widget_string] = True
            print("Empty text box detected, adding text widget to placeholder dictionary")
            if is_prompt_widget:
                widget.insert("1.0", "Type prompt here")
            else:
                widget.insert("1.0", "Type answer here")
        else:
            widget.config(fg = widgets_color_text)
            placeholder_active[widget_string] = False

    def generate_flashcard_widgets(i, entry):
        nonlocal location_box
        print(f"Item list: {item_list}")
        #item_widgets[f"round_{i}_frame"] = tk.Frame(statistics_frame, bg = widgets_color_medium, padx = 10)
        #frames[f"round_{i}_frame"].grid(row=(i + 1), column=0, columnspan = 2, sticky = "nsew")  # Use grid consistently
        
        # ==== Set up title widgets ====
        #clear_content()
        #flashcard_creation_frame_border = tk.Frame(content_frame, bg = navigation_color_buttons)
        #flashcard_creation_frame_border.grid(row = 3, column = 0, columnspan = 3, padx = 50, pady = 8)
        #flashcard_creation_frame = tk.Frame(flashcard_creation_frame_border, bg = widgets_color_medium)
        #flashcard_creation_frame.pack(padx = 8, pady = 8)
        nonlocal flashcard_widgets

        #for r, widget in enumerate(flashcard_widgets):
        #    print(f"clearing old widgets: {widget} ({r})")
        #    flashcard_widgets[widget].destroy()
        
        answer = ""
        prompt = ""
        image_path = None
        match = re.match(r'^(.*?)\t(.*?)(?:\t(.*))?$', entry)
        if match:
            prompt = match.group(2)
            answer = match.group(1)
            image_path = match.group(3) if match.group(3) else None
        else:
            prompt = entry

        if match:
            answer = match.group(1)
            print(f"term found: {answer}")
            prompt = match.group(2)
            print(f"definition found: {prompt}")
        else:
            prompt = entry

        print(f"prompt: {prompt}")
        print(f"Answer: {answer}")
        print(f"Number: {i}")

        #if not flashcard_widgets.get(f"widget_{i}_background"):
        flashcard_widgets[f"widget_{i}_background"] = tk.Frame(body_frame, bg = widgets_color_medium)
        flashcard_widgets[f"widget_{i}_background"].grid(row = i, column = 0, columnspan = 3, sticky = "nsew", padx = 8, pady = 8)
        
        flashcard_widgets[f"widget_{i}_background"].columnconfigure(0, minsize = 10, weight = 1)
        flashcard_widgets[f"widget_{i}_background"].columnconfigure(1, minsize = 300, weight = 16)
        flashcard_widgets[f"widget_{i}_background"].columnconfigure(2, minsize = 10)
        flashcard_widgets[f"widget_{i}_background"].columnconfigure(3, minsize = 300, weight = 16)
        flashcard_widgets[f"widget_{i}_background"].columnconfigure(4, weight = 0)

        flashcard_widgets[f"widget_{i}_number"] = tk.Label(flashcard_widgets[f"widget_{i}_background"], text = (i + 1), width = 3, height = 1, font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = widgets_color_medium, fg = widgets_color_text)
        flashcard_widgets[f"widget_{i}_number"].grid(row = 0, column = 0, columnspan = 2, sticky = "w", padx = (4, 0))
        flashcard_widgets[f"prompt_widget_{i}"] = tk.Text(flashcard_widgets[f"widget_{i}_background"], width = 5, height = 2, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
        flashcard_widgets[f"prompt_widget_{i}"].grid(row = 1, column = 3, pady = (0, 10), padx = (1, 10), sticky = "we")
        
        flashcard_widgets[f"prompt_widget_{i}"].insert("1.0", f"{prompt}")
        add_placeholder_text(flashcard_widgets[f"prompt_widget_{i}"], True)
        print("Mark 1: Prompt widget set up")

        flashcard_widgets[f"answer_widget_{i}"] = tk.Text(flashcard_widgets[f"widget_{i}_background"], width = 27, height = 2, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
        flashcard_widgets[f"answer_widget_{i}"].grid(row = 1, column = 1, pady = (0, 10), padx = (1, 10), sticky = "we")
        flashcard_widgets[f"answer_widget_{i}"].insert("1.0", f"{answer}")
        add_placeholder_text(flashcard_widgets[f"answer_widget_{i}"], False)

        print("Mark 2: response widget set up")
        flashcard_widgets[f"prompt_widget_{i}"].bind("<FocusIn>", lambda event, w=flashcard_widgets[f"prompt_widget_{i}"]: remove_placeholder_text(w, True))
        flashcard_widgets[f"answer_widget_{i}"].bind("<FocusIn>", lambda event, w=flashcard_widgets[f"answer_widget_{i}"]: remove_placeholder_text(w, False))
        flashcard_widgets[f"prompt_widget_{i}"].bind("<FocusOut>", lambda event, w=flashcard_widgets[f"prompt_widget_{i}"]: add_placeholder_text(w, True))
        flashcard_widgets[f"answer_widget_{i}"].bind("<FocusOut>", lambda event, w=flashcard_widgets[f"answer_widget_{i}"]: add_placeholder_text(w, False))

        print("Mark 3: placeholder text set up")
        flashcard_widgets[f"widget{i}_image"] = tk.Button(flashcard_widgets[f"widget_{i}_background"], text = "+", width = 2, height = 2, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda entry_number_send = i: add_image(entry_number_send))
        flashcard_widgets[f"widget{i}_image"].grid(row = 0, column = 4, rowspan = 2, pady = 10)
        flashcard_widgets[f"widget{i}_image"].bind("<Enter>", lambda event, tooltip_send = f"Add/change image": on_hover(event, "light", tooltip_send))
        flashcard_widgets[f"widget{i}_image"].bind("<Leave>", lambda event: on_default(event, "light"))

        if image_path:
            print(f"Image found: {image_path}")

            # ==== Image path may be abbreviated (images within the 'MonarchFlashcards' file get abbreviated to allow easier sharing between users) ====
            if os.path.isabs(image_path):
                # It's already an absolute path
                try:
                    img = Image.open(image_path)
                except:
                    img = None
            else:
                # It's a relative path - combine with DATA_DIR
                try:
                    full_path = os.path.join(DATA_DIR, image_path)
                
                    img = Image.open(full_path)
                except:
                    img = None

            if img:
                img.thumbnail((80, 80))
                photo = ImageTk.PhotoImage(img)

                # Create a label to display it
                #image_label = tk.Label(content_frame, image=photo)
                #image_label.image = photo  # Keep a reference!
                #image_label.grid(row=0, column=3, columnspan = 5, rowspan = 4, sticky = "nw")
                flashcard_widgets[f"widget{i}_image"].image = photo
                flashcard_widgets[f"widget{i}_image"].config(image = photo, width = 80, height = 80)

                flashcard_widgets[f"widget{i}_remove_image"] = tk.Button(flashcard_widgets[f"widget_{i}_background"], text = "X", relief = "flat", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda entry_number_send = i: add_image(entry_number_send, True))
                flashcard_widgets[f"widget{i}_remove_image"].grid(row = 0, column = 4, rowspan = 2, sticky = "ne", pady = 12, padx = 2)
                flashcard_widgets[f"widget{i}_remove_image"].bind("<Enter>", lambda event, tooltip_send = f"Remove image": on_hover(event, "light", tooltip_send))
                flashcard_widgets[f"widget{i}_remove_image"].bind("<Leave>", lambda event: on_default(event, "light"))

                flashcard_widgets[f"widget{i}_remove_image"].bind("<Enter>", lambda event, palette = "light", tooltip_send = "Remove this image": on_hover(event, palette, tooltip_send))
                flashcard_widgets[f"widget{i}_remove_image"].bind("<Leave>", lambda event, palette = "light": on_default(event, palette))

        print("Mark 4: first button set up")
        last_item_index = len(item_list) - 1
        if i != last_item_index: # don't generate this widget on the very last item
            flashcard_widgets[f"widget{i}_move_forward"] = tk.Button(flashcard_widgets[f"widget_{i}_background"], text = "↓", width = 2, height = 1, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: switch_items(i, True))
            flashcard_widgets[f"widget{i}_move_forward"].grid(row = 1, column = 5, padx = 4, pady = (0, 10))
            flashcard_widgets[f"widget{i}_move_forward"].bind("<Enter>", lambda event, tooltip_send = "Move down": on_hover(event, "light", tooltip_send))
            flashcard_widgets[f"widget{i}_move_forward"].bind("<Leave>", lambda event: on_default(event, "light"))

        print("Mark 5: second button set up")
        if i != 0: # don't generate this button on the very first item
            flashcard_widgets[f"widget{i}_move_backward"] = tk.Button(flashcard_widgets[f"widget_{i}_background"], text = "↑", width = 2, height = 1, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: switch_items(i, False))
            flashcard_widgets[f"widget{i}_move_backward"].grid(row = 0, column = 5, padx = 4, pady = (10, 0))
            flashcard_widgets[f"widget{i}_move_backward"].bind("<Enter>", lambda event, tooltip_send = "Move up": on_hover(event, "light", tooltip_send))
            flashcard_widgets[f"widget{i}_move_backward"].bind("<Leave>", lambda event: on_default(event, "light"))
        print("Mark 6: third button set up")

        flashcard_widgets[f"widget{i}_delete_entry"] = tk.Button(flashcard_widgets[f"widget_{i}_background"], text = "X", width = 2, height = 1, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda entry_number = i: delete_entry(entry_number))
        flashcard_widgets[f"widget{i}_delete_entry"].grid(row = 0, column = 6, padx = 4, pady = (10, 0))
        flashcard_widgets[f"widget{i}_delete_entry"].bind("<Enter>", lambda event, tooltip_send = "Delete this entry": on_hover(event, "light", tooltip_send))
        flashcard_widgets[f"widget{i}_delete_entry"].bind("<Leave>", lambda event: on_default(event, "light"))
        #print("Mark 3: generate lists for next round")
        #globals()[f"round_{next_round_number}_must_study"] = []
        #globals()[f"round_{next_round_number}_correct"] = []
        #globals()[f"round_{next_round_number}_incorrect"] = []
        #globals()[f"round_{next_round_number}_study_progress"] = []

        #if not globals().get(f"round_{round_number}_must_study", []):

    if edit_mode == False:
        item_list.append("")
    for i, entry in enumerate(item_list):
        generate_flashcard_widgets(i, entry)

    def update_entry(entry_number):
        entry = item_list[entry_number]

        # ==== get image path ====
        match = re.match(r'^(.*?)\t(.*?)(?:\t(.*))?$', entry)
        if match:
            prompt = match.group(2)
            answer = match.group(1)
            image_path = match.group(3) if match.group(3) else None
        else:
            prompt = entry
            image_path = None

        # ==== get the updated prompt and answer ====
        remove_placeholder_text(flashcard_widgets[f"prompt_widget_{entry_number}"], True)
        new_prompt = flashcard_widgets[f"prompt_widget_{entry_number}"].get("1.0", "end-1c")
        remove_placeholder_text(flashcard_widgets[f"answer_widget_{entry_number}"], True)
        new_answer = flashcard_widgets[f"answer_widget_{entry_number}"].get("1.0", "end-1c")

        if image_path:
            new_entry = f"""{new_answer}\t{new_prompt}\t{image_path}"""
        else:
            new_entry = f"""{new_answer}\t{new_prompt}"""
        #item_list[entry_number] = new_entry
        print(f"Item list updated: Item {entry_number} = {item_list[entry_number]}")

        return new_entry

    def delete_entry(entry_number):
        nonlocal item_list, flashcard_widgets
        print(f"Item list: {item_list}")
        temp_list = []

        for m, entry in enumerate(item_list):
            if m != entry_number:
                new_entry = update_entry(m)
                print(f"Item {m}: New entry: {new_entry} Old entry: {entry}")
                temp_list.append(new_entry)
            else:
                print(f"Item {m}: Match found, {entry} should be deleted")

        print(f"Finished processing temp_list: {temp_list}")

        item_list = temp_list

        #for widget in body_frame.winfo_children():
        #    print(f"Destroying widget: {widget}")
        #    widget.destroy()
        last_entry_index = len(temp_list)
        print(f"Last entry index: {last_entry_index}")
        #for widget in body_frame.winfo_children():
        #    widget.destroy()
        #    widget = None
        flashcard_widgets[f"widget_{last_entry_index}_background"].destroy()
        del flashcard_widgets[f"widget_{last_entry_index}_background"]
        #flashcard_widgets = []

        #flashcard_widgets[f"test_widget"] = tk.Label(create_flashcards_scrollable_frame, text="Hello, world!", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = widgets_color_text, height=1)
        #flashcard_widgets[f"test_widget"].grid(row=0, column=1, sticky="w", padx=50, pady=(50, 0))
        #flashcard_widgets[f"test_widget"].destroy()
        #flashcard_widgets[f"test_widget"] = tk.Label(create_flashcards_scrollable_frame, text="Hello, world!", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = "red", height=1)
        #flashcard_widgets[f"test_widget"].grid(row=0, column=1, sticky="w", padx=50, pady=(50, 0))
        
        #flashcard_widgets[f"test_widget"]
        #flashcard_widgets[f"test_widget"]
        for p, entry in enumerate(temp_list):
            generate_flashcard_widgets((p), entry)

        return

        """for m, entry in enumerate(item_list):
            if m < entry_number:
                new_entry = update_entry(m)
                flashcard_widgets[f"widget_{m}_background"].destroy()
                generate_flashcard_widgets(m, new_entry)
                temp_list.append(new_entry)
            if m == entry_number:
                flashcard_widgets[f"widget_{m}_background"].destroy()
            if m > entry_number:
                new_entry = update_entry(m)
                flashcard_widgets[f"widget_{m}_background"].destroy()
                generate_flashcard_widgets((m - 1), new_entry)
                temp_list.append(new_entry)

        item_list = temp_list
        print(f"Updated item_list: {item_list}")"""

        """nonlocal item_list
        # ==== variables for logic ====
        final_item_number = len(item_list)
        final_widget_index = final_item_number - 1

        # ==== Take all the widgets that came after deleted item, delete them and regenerate them 1 place back. (this maintains serial order which is important for not breaking things) ====
        temp_list = []
        for j, entry in enumerate(item_list):
            if j != entry_number:
                new_entry = update_entry(j)
                temp_list.append(new_entry)

        item_list = temp_list

        for k, entry in enumerate(item_list):
            for widget in flashcard_widgets[f"widget_{k}_background"].winfo_children():
                    widget.destroy()
            flashcard_widgets[f"widget_{k}_background"].destroy()
            generate_flashcard_widgets(k, entry)
        # ==== destroy the (now unused) ultimate widget ====
        for widget in flashcard_widgets[f"widget_{final_widget_index}_background"].winfo_children():
            widget.destroy()
        flashcard_widgets[f"widget_{final_widget_index}_background"].destroy()"""
    
    def add_new_item():
        new_item_index = len(item_list)
        print(f"Length of item list: {new_item_index}")
        item_list.append("")
        generate_flashcard_widgets(new_item_index, "")

        # ==== regenerate the widget that used to be very last (so that it has both move_forward and move_backward buttons) ====

        former_last = new_item_index - 1
        former_last_item = update_entry(former_last)
        for widget in flashcard_widgets[f"widget_{former_last}_background"].winfo_children():
            widget.destroy()
        generate_flashcard_widgets(former_last, former_last_item)
        #flashcard_widgets[f"widget_{i}_background"]

    def switch_items(selected_entry_number, forward):
        print("Rearrange items")
        #for r, item in enumerate(item_list):
        #    print(f"{r}. {item}")

        #flashcard_widgets[f"widget_{i}_background"].grid(row = i, column = 0, columnspan = 3, rowspan = 2, sticky = "nsew", padx = 50, pady = 10)

        preceding_entry_number = selected_entry_number - 1
        next_entry_number = selected_entry_number + 1

        #try:
        #    preceding_entry = item_list[preceding_entry_number]
        #except:
        #    print("Could not find preceding flashcard entry")
        #    preceding_entry = None
        #selected_entry = item_list[selected_entry_number]
        #try:
        #    next_entry = item_list[next_entry_number]
        #except:
        #    print("Could not find next flashcard entry")
        #    next_entry = None

        #print(f"preceding entry: {preceding_entry} ({preceding_entry_number})")
        #print(f"selected entry: {selected_entry} ({selected_entry_number})")
        #print(f"next entry: {next_entry} ({next_entry_number})")

        if forward == True:
            selected_entry = update_entry(selected_entry_number)
            next_entry = update_entry(next_entry_number)

            for widget in flashcard_widgets[f"widget_{selected_entry_number}_background"].winfo_children():
                widget.destroy()
            for widget in flashcard_widgets[f"widget_{next_entry_number}_background"].winfo_children():
                widget.destroy()

            generate_flashcard_widgets(selected_entry_number, next_entry)
            generate_flashcard_widgets(next_entry_number, selected_entry)

            item_list[selected_entry_number] = next_entry
            item_list[next_entry_number] = selected_entry
        else:
            selected_entry = update_entry(selected_entry_number)
            preceding_entry = update_entry(preceding_entry_number)
            for widget in flashcard_widgets[f"widget_{selected_entry_number}_background"].winfo_children():
                widget.destroy()
            for widget in flashcard_widgets[f"widget_{preceding_entry_number}_background"].winfo_children():
                widget.destroy()

            # destroy old widgets and replace with new ones

            generate_flashcard_widgets(preceding_entry_number, selected_entry)
            generate_flashcard_widgets(selected_entry_number, preceding_entry)

            item_list[preceding_entry_number] = selected_entry
            item_list[selected_entry_number] = preceding_entry

        print("Finished switching items")
        for r, item in enumerate(item_list):
            print(f"{r}. {item}")

        for widget in body_frame.winfo_children():
            print(widget)

    def add_image(entry_number, remove_image = False):
        if remove_image == False:
            new_image_path = filedialog.askopenfilename(
                title="Select an image file",
                filetypes=(("Image files", "*.png *.jpg *.jpeg *.gif"), ("All files", "*.*"))
            )
        else:
            print("attempt to remove image")
            new_image_path = None

        remove_placeholder_text(flashcard_widgets[f"prompt_widget_{entry_number}"], True)
        new_prompt = flashcard_widgets[f"prompt_widget_{entry_number}"].get("1.0", "end-1c")
        remove_placeholder_text(flashcard_widgets[f"answer_widget_{entry_number}"], True)
        new_answer = flashcard_widgets[f"answer_widget_{entry_number}"].get("1.0", "end-1c")

        if new_image_path:
            if os.path.commonpath([new_image_path, DATA_DIR]) == DATA_DIR:
                # Image is inside DATA_DIR, abbreviate it (abbreviating the path lets users share decks more easily if other people installed differently or use a different operating system)
                new_image_path = os.path.relpath(new_image_path, DATA_DIR)

        if new_image_path:
            new_image_path_new_string = os.path.relpath(new_image_path, DATA_DIR)
            print(f"New image path new string: {new_image_path_new_string}")
        if remove_image == True:
            new_entry = f"{new_answer}\t{new_prompt}"
        else:
            if new_image_path:
                new_entry = f"{new_answer}\t{new_prompt}\t{new_image_path}"
            else:
                return # should trigger if user clicks cancel in file explorer
        
        item_list[entry_number] = new_entry

        # ==== update widgets ====

        for widget in flashcard_widgets[f"widget_{entry_number}_background"].winfo_children():
            widget.destroy()
        
        generate_flashcard_widgets(entry_number, new_entry)
        print("finished configuring image")

    def save_flashcards():
        nonlocal item_list, path_save, error_box

        save_list = []

        for entry_number, entry in enumerate(item_list):
            # ==== retrieve entries from memory. This step only needs to retrieve the image_path though. ====
            match = re.match(r'^(.*?)\t(.*?)(?:\t(.*))?$', entry)
            if match:
                prompt = match.group(2)
                answer = match.group(1)
                image_path = match.group(3) if match.group(3) else None
            else:
                image_path = None

            # ==== get the updated prompt and answer ====
            remove_placeholder_text(flashcard_widgets[f"prompt_widget_{entry_number}"], True)
            new_prompt = flashcard_widgets[f"prompt_widget_{entry_number}"].get("1.0", "end-1c")
            remove_placeholder_text(flashcard_widgets[f"answer_widget_{entry_number}"], True)
            new_answer = flashcard_widgets[f"answer_widget_{entry_number}"].get("1.0", "end-1c")

            if not new_prompt:
                create_flashcards_canvas.yview_moveto(0)
                error_box = tk.Label(create_flashcards_scrollable_frame, text=f"Error, missing prompt in entry {entry_number + 1}", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = "red", height=1)
                error_box.grid(row=2, column=0, columnspan = 3, sticky="s", padx=50, pady=8)

                return
            if not new_answer:
                create_flashcards_canvas.yview_moveto(0)
                error_box = tk.Label(create_flashcards_scrollable_frame, text=f"Error, missing answer in entry {entry_number}", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = "red", height=1)
                error_box.grid(row=2, column=0, columnspan = 3, sticky="s", padx=50, pady=8)

                return

            if image_path:
                new_entry = f"""{new_answer}\t{new_prompt}\t{image_path}"""
            else:
                new_entry = f"""{new_answer}\t{new_prompt}"""

            save_list.append(new_entry)

        title = title_box.get("1.0", "end-1c")
        if title:

            invalid_chars = r'\/:*?"<>|'

            for char in title:
                if char in invalid_chars:
                    title_label.config(fg = "red", text = """Error: Title can not contain \ / : * ? " < >""")
                    return

            if not title.endswith(".txt"):
                title_txt = f"{title}.txt"
                title = title_txt
        else:
            print("Error: title not found")

            create_flashcards_canvas.yview_moveto(0)

            title_label.config (fg = "red", text = "Error: Your deck needs a title!")
            
            return
        
        if save_list:
            print(f"Item_list: {save_list}")

        else:
            print("Error: Could not find item list")
            create_flashcards_canvas.yview_moveto(0)
            error_box = tk.Label(create_flashcards_scrollable_frame, text="Error, deck must have at least 1 term", font=(app_settings['font'], app_settings['font_size']), justify="left", bg = widgets_color_medium, fg = "red", height=1)
            error_box.grid(row=2, column=0, columnspan = 3, sticky="s", padx=50, pady=8)
            return
        
        os.makedirs(path_save, exist_ok=True)
        
        flashcard_file_name = os.path.join(path_save, title)

        if edit_mode == True:
            # ==== save items and rename deck to new title ====
            print("Saving deck (edit mode)")
            try:
                with open(path_send, 'w', encoding = 'utf-8') as f:
                    for entry in save_list:
                        f.write(f"{entry}\n")
                os.rename(path_send, flashcard_file_name)
            except:
                print("Error saving flashcard set")

            # ==== statistics file should be updated if the name of the deck changed ====
            # ==== compare names ====
            match = re.search(r'(-?\d+)[_ -](.+)', original_title)
            if match:
                original_title_bare = match.group(2)
                original_title_no_ext = os.path.splitext(original_title_bare)[0]  # Remove extension
            else:
                original_title_no_ext = os.path.splitext(original_title)[0] # if no match found (unlikely) just display file name

            print(f"Mark W: original title = {original_title_no_ext}")

            match2 = re.search(r'(-?\d+)[_ -](.+)', title)
            if match2:
                title_bare = match2.group(2)
                title_no_ext = os.path.splitext(title_bare)[0]  # Remove extension
            else:
                title_no_ext = os.path.splitext(title)[0] # if no match found (unlikely) just display file name

            print(f"Mark X: title = {title_no_ext}")

            print(f"Original title: {original_title}")
            print(f"New title: {title}")

            print(f"Original title: {original_title_no_ext}")
            print(f"New title: {title_no_ext}")

            # ==== update statistics ====
            if title_no_ext != original_title_no_ext:
                print("Title mismatch, must update statistics")
                statistics = []
                try:
                    if os.path.exists(STATS_FILE):
                        with open(STATS_FILE, 'r', encoding='utf-8') as f:
                            lines = f.readlines()
                            
                            for line in lines:
                                line = line.strip()
                                if line:
                                    match
                                    statistics.append(eval(line))
                        
                        print(f"Mark 1 Statistics: {statistics}")
                except Exception as e:
                    print(f"Error: {e}")
                    return

                new_statistics = []
                for tuple in statistics:
                    date = tuple[0]
                    deck_name = tuple[1]
                    grade = tuple[2]

                    print(f"{deck_name}, {original_title_no_ext}")

                    if f"{deck_name}" == f"{original_title_no_ext}":
                        print("Match found, must update old data to match the new flashcard deck's name")
                        new_statistics.append((date, grade, title_no_ext))
                    else:
                        new_statistics.append((date, grade, deck_name))

                # ==== save updated statistics ====
                try:
                    with open(STATS_FILE, 'w', encoding='utf-8') as f:
                        for line in new_statistics:
                            f.write(f"{line}\n")
                except Exception as e:
                    print(f"Error saving settings: {e}")

        else:
            print("Saving deck (normal mode)")
            try:
                with open(flashcard_file_name, 'w', encoding = 'utf-8') as f:
                    for entry in save_list:
                        f.write(f"{entry}\n")
            except:
                print("Error saving flashcard set")

        clear_content()
        content_frame.columnconfigure(0, weight = 1)
        content_frame.columnconfigure(1, weight = 1)
        flashcards_saved_label = tk.Label(content_frame, text = "Deck saved successfully!", bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), padx = 20, pady = 20)
        flashcards_saved_label.grid(row = 0, column = 0, columnspan = 2, padx = 20, pady = 20, sticky = "nsew")

        create_another_set_button = tk.Button(content_frame, text = "Create another deck", bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), command = lambda: create_new_flashcards())
        create_another_set_button.grid(row = 1, column = 0, padx = 20, pady = 20)
        create_another_set_button.bind("<Enter>", lambda event, tooltip_send = "Create another deck": on_hover(event, "dark", tooltip_send))
        create_another_set_button.bind("<Leave>", lambda event: on_default(event, "dark"))

        study_this_set_button = tk.Button(content_frame, text = "Study this deck", bg = navigation_color_buttons, fg = navigation_color_text, font=(app_settings['font'], app_settings['font_size']), command = lambda: flashcard_set_overview(flashcard_file_name))
        study_this_set_button.grid(row = 1, column = 1, padx = 20, pady = 20)
        study_this_set_button.bind("<Enter>", lambda event, tooltip_send = "Study this deck": on_hover(event, "dark", tooltip_send))
        study_this_set_button.bind("<Leave>", lambda event: on_default(event, "dark"))
    
    folder_select_frame = tk.Frame(create_flashcards_scrollable_frame)
    def path_manager(folder_path_send = path_save):
        print("Path manager called")

            # Create main frame
        folder_select_frame = tk.Frame(create_flashcards_scrollable_frame)
        folder_select_frame.grid(row = 2, column = 0, rowspan = 6, columnspan=3, padx=50, pady=(0, 15), sticky = "nwe")
        folder_select_frame.configure(bg = widgets_color_light)

        for widget in folder_select_frame.winfo_children():
            print(f"Destroying {widget}")
            widget.destroy()

        #folder_select_frame_label = tk.Label
        folder_select_frame_top = tk.Frame(folder_select_frame, bg = navigation_color_backgrounds)
        folder_select_frame_top.pack(side="top", fill = "both", expand = True)

        folder_select_frame_label = tk.Label(folder_select_frame_top, bg = navigation_color_backgrounds, fg = "gray", font=(app_settings['font'], app_settings['font_size']), text = "Choose a file destination")
        folder_select_frame_label.pack(side = "left", fill = "both", expand = True)

        def close_path_manager(path_select = path_save):
            print("Attempt to close location manager menu")
            nonlocal location_box, location_box_string, path_save
            location_box_string = os.path.relpath(path_select, DATA_DIR)
            location_box_string_no_index = re.sub(r'\d+_', '', location_box_string)
            location_box.config(text = f"Save location: {location_box_string_no_index}")
            location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string_no_index}": on_hover(event, "light", tooltip_send))
            location_box.bind("<Leave>", lambda event: on_default(event, "light"))
            path_save = path_select
            #nonlocal folder_select_frame
            for menu_item in folder_select_frame.winfo_children():
                print(f"{menu_item}")
                menu_item.destroy()
            folder_select_frame.destroy()
        
            location_box.config(command = lambda: path_manager(path_save))

            configure_main_scroll_region()

        location_box.config(command = lambda: close_path_manager())
        location_box.bind("<Enter>", lambda event, tooltip_send = f"Save to: {location_box_string_no_index}": on_hover(event, "light", tooltip_send))
        location_box.bind("<Leave>", lambda event: on_default(event, "light"))

        folder_select_frame_exit_button = tk.Button(folder_select_frame_top, bg = navigation_color_backgrounds, fg = "gray", font=(app_settings['font'], app_settings['font_size']), text = "X", command = lambda: close_path_manager())
        folder_select_frame_exit_button.pack(side="right", fill = "both")
        folder_select_frame_exit_button.bind("<Enter>", lambda event, tooltip_send = "Exit": on_hover(event, "dark", tooltip_send))
        folder_select_frame_exit_button.bind("<Leave>", lambda event: on_default(event, "dark"))

        # Create canvas and scrollbar
        folder_select_canvas = tk.Canvas(folder_select_frame, bg = widgets_color_light)
        scrollbar = tk.Scrollbar(folder_select_frame, orient=tk.VERTICAL, command=folder_select_canvas.yview)
        scrollable_frame = tk.Frame(folder_select_canvas, bg = widgets_color_light)

        # Configure canvas scrolling
        folder_select_canvas.configure(yscrollcommand=scrollbar.set)
        folder_select_canvas.bind('<Configure>', lambda e: folder_select_canvas.configure(scrollregion=folder_select_canvas.bbox("all")))

        window_id2 = folder_select_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        def configure_scroll_region(event):
            # Update scroll region based on canvas contents
            create_flashcards_canvas.configure(scrollregion=create_flashcards_canvas.bbox("all"))
            
            # Make the frame fill the canvas width
            canvas_width = create_flashcards_canvas.winfo_width()
            create_flashcards_canvas.itemconfig(window_id2, width=canvas_width)

            create_flashcards_canvas.bind('<Configure>', configure_scroll_region)

        if system == "Windows" or system =="Darwin":
            print("setup scroll for Windows/Mac")
            def on_mousewheel2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

            root.bind("<MouseWheel>", on_mousewheel2)  # Windows/Mac
        else:
            print("setup scroll for Linux")
            def on_mousewheel_linux_down2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(-1, "units")
                else:
                    print("Could not scroll")

            def on_mousewheel_linux_up2(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                folder_select_canvas_height = folder_select_canvas.winfo_height()
                scrollable_frame_height = scrollable_frame.winfo_height()

                print(f"Folder select canvas height: {folder_select_canvas_height}, Scrollable frame height: {scrollable_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if folder_select_canvas_height < scrollable_frame_height:
                    print("attempt to scroll")
                    folder_select_canvas.yview_scroll(1, "units")
                else:
                    print("Could not scroll")

            root.bind("<Button-4>", on_mousewheel_linux_up2)  # Linux
            root.bind("<Button-5>", on_mousewheel_linux_down2)  # Linux

        # Create window inside canvas
        folder_select_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # Pack scrollbar and canvas
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        folder_select_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Now add buttons to scrollable_frame instead of main_frame

        flashcard_master = [] # list to use for creating flashcard buttons
        def generate_folder_buttons(path_select):
            nonlocal location_box, path_save
            path_save = path_select
            print(f"Open folders list: {path_select}")

            folders = [] # list of file names in current_file_path
            folders += os.listdir(path_save) # add files in current_file_path to items

            folders.sort()

            for widget in scrollable_frame.winfo_children():
                widget.destroy()
            if path_save != FLASHCARDS_DIR:
                folders.insert(0,"Back")

            folder_detected = False

            for item in folders:
                match = re.search(r'(-?\d+)[_ -](.+)', item)
                if match:
                    display_name = match.group(2)
                    display_name_no_ext = os.path.splitext(display_name)[0]  # Remove extension
                else:
                    display_name_no_ext = os.path.splitext(item)[0] # if no match found (unlikely) just display file name

                print(f"Mark X: display name = {display_name_no_ext}")

                button_command = None
                button_color_palette = "medium"
                try:
                    full_path = os.path.join(path_save, item)
                except:
                    full_path = path_save
                print(f"Path: {path_save}")
                print(f"Full path: {full_path}")
                if os.path.isdir(full_path):  # Check the full path
                    print(f"Folder detected: {item}")
                    symbol = "  ▶"
                    button_command = lambda path=full_path: close_path_manager(path)
                    button_color_palette = "medium"
                    background = widgets_color_medium
                    foreground = widgets_color_text

                    btn = tk.Button(
                        scrollable_frame,
                        text = f"""{symbol} {display_name_no_ext}""",
                        width=100, 
                        height=1, 
                        font=(app_settings['font'], app_settings['font_size']),
                        anchor="w",
                        relief="flat",
                        bd=0,
                        command=button_command,
                        bg = background, 
                        fg = foreground)
                    btn.pack(pady=1, padx=1)

                    btn.bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))
                    btn.bind('<Enter>', lambda event, palette=button_color_palette, tooltip_text = "Select this folder": on_hover(event, palette, tooltip_text))

                    folder_detected = True

                elif item == "Back":
                    print(f"Back button detected: {item}")
                    symbol = "←"
                    button_command = lambda path = os.path.dirname(path_save): close_path_manager(path) # Go back to last file location
                    button_color_palette = "medium"
                    background = widgets_color_medium
                    foreground = widgets_color_text
            
                    btn = tk.Button(
                        scrollable_frame,
                        text = f"""{symbol} {display_name_no_ext}""",
                        width=100, 
                        height=1, 
                        font=(app_settings['font'], app_settings['font_size']),
                        anchor="w",
                        relief="flat",
                        bd=0,
                        command=button_command,
                        bg = background, 
                        fg = foreground)
                    btn.pack(pady=1, padx=1)

                    btn.bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))
                    btn.bind('<Enter>', lambda event, palette=button_color_palette: on_hover(event, palette))
        generate_folder_buttons(folder_path_send)

def flashcards_clicked(selected_file_path = FLASHCARDS_DIR): # run with FLASHCARDS_DIR as default value of current_file_path
    global tooltip_tracker, tooltip_holder, open_in_file_explorer_button, open_in_file_explorer_button_frame, current_file_path
    current_file_path = selected_file_path
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    clear_content()
    content_frame.pack(fill="both", expand=True, padx=10, pady=(56, 10))

    def open_in_file_explorer(item_send):
        if system == "Windows":
            #Windows
            subprocess.run(['explorer', item_send])
        elif system =="Darwin":
            # Mac
            subprocess.run(['open', item_send])
        else:
            # Linux
            subprocess.run(['xdg-open', item_send])
    
    check_for_name_errors(selected_file_path)
    items = [] # list of file names in selected_file_path
    items += os.listdir(selected_file_path) # add files in selected_file_path to items

    items.sort()

        # Create main frame
    main_frame = tk.Frame(content_frame)
    main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(5))
    main_frame.configure(bg = widgets_color_light)

    folder_label_str = os.path.basename(selected_file_path)
    match2 = re.search(r'(-?\d+)[_ -](.+)', folder_label_str)
    if match2:
        folder_label_str2 = match2.group(2)
        folder_label_str_no_ext = os.path.splitext(folder_label_str2)[0]  # Remove extension
    else:
        folder_label_str_no_ext = os.path.splitext(folder_label_str)[0] # if no match found (unlikely) just display file name

    folder_label = tk.Label(main_area, text = folder_label_str_no_ext, font=(app_settings['font'], 24), bg = navigation_color_backgrounds, fg = navigation_color_text)
    folder_label.place(relx = .4, rely = 0, y = 5)

    # Create canvas and scrollbar
    canvas = tk.Canvas(main_frame, bg = widgets_color_light)
    scrollbar = tk.Scrollbar(main_frame, orient=tk.VERTICAL, command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg = widgets_color_light)

    # Configure canvas scrolling
    canvas.configure(yscrollcommand=scrollbar.set)
    canvas.bind('<Configure>', lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

    if system == "Windows" or system == "Darwin":
        print("setup scroll for Windows/Mac")
        def on_mousewheel(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if canvas_height < scrollable_frame_height:
                print("attempt to scroll")
                canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
            else:
                print("Could not scroll")

        root.bind("<MouseWheel>", on_mousewheel)  # Windows/Mac
    else:
        print("setup scroll for Linux")
        def on_mousewheel_linux_down(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if canvas_height < scrollable_frame_height:
                print("attempt to scroll")
                canvas.yview_scroll(-1, "units")
            else:
                print("Could not scroll")

        def on_mousewheel_linux_up(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            print("attempt to scroll")
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if canvas_height < scrollable_frame_height:
                canvas.yview_scroll(1, "units")
            else:
                print("Could not scroll")

        root.bind("<Button-4>", on_mousewheel_linux_up)  # Linux
        root.bind("<Button-5>", on_mousewheel_linux_down)  # Linux

    # Create window inside canvas
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

    # Pack scrollbar and canvas
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady = (0, 46))
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    open_in_file_explorer_button_frame = tk.Frame(root, bg = navigation_color_backgrounds, bd = 0, relief = "flat")
    open_in_file_explorer_button_frame.place(relx = 1, rely = 0, x = 0, y = 0, anchor = "ne")
    open_in_file_explorer_button = tk.Button(open_in_file_explorer_button_frame, text = "Open in file explorer", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, command = lambda: open_in_file_explorer(selected_file_path))
    open_in_file_explorer_button.pack(padx = 8, pady = 8)
    open_in_file_explorer_button.bind("<Enter>", lambda event, tooltip_send = "Open in file explorer": on_hover(event, "medium", tooltip_send))
    open_in_file_explorer_button.bind("<Leave>", lambda event: on_default(event, "medium"))
 
    # Now add buttons to scrollable_frame instead of main_frame

    flashcard_master = [] # list to use for creating flashcard buttons
    first_item_index = 0 # tracks position that first user-created widget gets placed

    if selected_file_path != FLASHCARDS_DIR:
        items.insert(0, "Back")
        first_item_index = 1

    items.append("Create new")

    flashcard_buttons = {} # dictionary to store the widgets in     flashcard_buttons[f"{item}"]

    def generate_widgets(i, item):
        nonlocal scrollable_frame, flashcard_buttons
        match = re.search(r'(-?\d+)[_ -](.+)', item)
        if match:
            display_name = match.group(2)
            display_name_no_ext = os.path.splitext(display_name)[0]  # Remove extension
        else:
            display_name_no_ext = os.path.splitext(item)[0] # if no match found (unlikely) just display file name
        
        print(f"Mark Y: display name = {display_name_no_ext}")

        button_command = None
        button_color_palette = "medium"

        full_path = os.path.join(selected_file_path, item)
    
        if item.lower().endswith(('.txt', '.midi', '.pdf')):
            symbol = "   •"
            button_command = lambda item_send = full_path: flashcard_set_overview(item_send)
            button_color_palette = "medium"
            background = widgets_color_medium
            foreground = widgets_color_text
            tooltip = "Study this deck"
        elif item == "Back":
            symbol = "←"
            button_command = lambda: flashcards_clicked(os.path.dirname(selected_file_path)) # Go back to last file location
            button_color_palette = "medium"
            background = widgets_color_medium
            foreground = widgets_color_text
            tooltip = "Back"
        elif item == "Create new":
            symbol = "    ✎"
            button_command = lambda: choose_create_new()
            button_color_palette = "medium"
            background = widgets_color_medium
            foreground = widgets_color_text
            tooltip = "Create new flashcard deck or folder"
        elif os.path.isdir(full_path):  # Check the full path
            symbol = "  ▶"
            button_command = lambda path=full_path: flashcards_clicked(path)
            button_color_palette = "medium_dark"
            background = widgets_color_medium_dark
            foreground = widgets_color_text
            tooltip = "Open this folder"
        else: # exceptions most likely to be folders
            symbol = "  ▶"
            button_command = lambda path=full_path: flashcards_clicked(path)
            button_color_palette = "medium_dark"
            background = widgets_color_medium_dark
            foreground = widgets_color_text
            tooltip = "Open this folder"

        print(f"File type determined: {tooltip}")

        print(f"i = {i}")
        print(f"scrollable_frame exists: {scrollable_frame}")
        print(f"background = {background}")

        flashcard_buttons[f"{i}_frame"] = tk.Frame(scrollable_frame, width=77, height=1, bg = background)
        flashcard_buttons[f"{i}_frame"].grid(row = i, column = 0, pady=1, padx=1, sticky = "we")
        flashcard_buttons[f"{i}_frame"].columnconfigure(0, weight = 1)

        size_widget = tk.Label(flashcard_buttons[f"{i}_frame"], text = f"{display_name_no_ext}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, wraplength = 750) # button widgets don't handle long strings of text well so this widget helps set the size of the button frame, then stays in the background
        size_widget.grid(row = 0, column = 0, sticky = "w", pady = 1, padx = 1)

        flashcard_buttons[f"{i}_button"] = tk.Button(flashcard_buttons[f"{i}_frame"], text = f"""{symbol} {display_name_no_ext}""", width=72, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="w", relief="flat", bd=0, command=button_command, bg = background, fg = foreground)
        flashcard_buttons[f"{i}_button"].grid(row = 0, column = 0, pady=1, padx=1, sticky = "nswe")
        flashcard_buttons[f"{i}_button"].bind('<Enter>', lambda event, palette=button_color_palette, tooltip_send = tooltip: on_hover(event, palette, tooltip_send))
        flashcard_buttons[f"{i}_button"].bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))
        
        # ==== set up the up and down arrows that let the user switch widgets around ====
        item_count = len(items)
        last_item_index = item_count - 1
        next_to_last_item_index = item_count - 2
        if first_item_index <= i:
            if i < next_to_last_item_index:
                flashcard_buttons[f"{i}_move_forward"] = tk.Button(flashcard_buttons[f"{i}_frame"], text = "↓", width=2, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="center", relief="flat", bd=0, command=lambda item_send = item, forward = True: rearrange_items(current_file_path, item_send, forward), bg = background, fg = foreground)
                flashcard_buttons[f"{i}_move_forward"].grid(row = 0, column = 1, pady=1, padx=1, sticky = "nswe")

                flashcard_buttons[f"{i}_move_forward"].bind("<Enter>", lambda event, palette = button_color_palette, tooltip_send = "Move down": on_hover(event, palette, tooltip_send))
                flashcard_buttons[f"{i}_move_forward"].bind('<Leave>', lambda event, palette = button_color_palette: on_default(event, palette))
                #move_forward_button.bind("<Button-1>", lambda: print("Button clicked"))
        
        if first_item_index < i:
            if i < last_item_index:
                flashcard_buttons[f"{i}_move_backward"] = tk.Button(flashcard_buttons[f"{i}_frame"], text = "↑", width=2, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="center", relief="flat", bd=0, command=lambda item_send = item, forward = False: rearrange_items(current_file_path, item_send, forward), bg = background, fg = foreground)
                flashcard_buttons[f"{i}_move_backward"].grid(row = 0, column = 2, pady=1, padx=1, sticky = "nswe")

                flashcard_buttons[f"{i}_move_backward"].bind("<Enter>", lambda event, palette = button_color_palette, tooltip_send = "Move up": on_hover(event, palette, tooltip_send))
                flashcard_buttons[f"{i}_move_backward"].bind('<Leave>', lambda event, palette = button_color_palette: on_default(event, palette))
        else:
            # create a dummy variable that is just used to place the move_forward_button in the correct spot
            flashcard_buttons[f"{i}_move_backward"] = tk.Button(flashcard_buttons[f"{i}_frame"], text = "", width=2, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="center", relief="flat", bd=0, bg = background, fg = foreground)
            flashcard_buttons[f"{i}_move_backward"].grid(row = 0, column = 2, pady=1, padx=1, sticky = "nswe")

        """
        temporary_frame = tk.Frame(scrollable_frame.master, bg = widgets_color_light)
        temporary_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        
        flashcard_buttons[f"{i}_frame_temporary"] = tk.Frame(temporary_frame, width=77, height=1, bg = background)
        flashcard_buttons[f"{i}_frame_temporary"].grid(row = i, column = 0, pady=1, padx=1)

        size_widget = tk.Label(flashcard_buttons[f"{i}_frame_temporary"], text = f"{display_name_no_ext}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, wraplength = 750) # button widgets don't handle long strings of text well so this widget helps set the size of the button frame, then stays in the background
        size_widget.grid(row = 0, column = 0, sticky = "w", pady = 1, padx = 1)

        flashcard_buttons[f"{i}_button_temporary"] = tk.Button(flashcard_buttons[f"{i}_frame_temporary"], text = f"{symbol} {display_name_no_ext}", width=72, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="w", relief="flat", bd=0, command=button_command, bg = background, fg = foreground)
        flashcard_buttons[f"{i}_button_temporary"].grid(row = 0, column = 0, pady=1, padx=1, sticky = "nswe")

        flashcard_buttons[f"{i}_button_temporary"].bind('<Enter>', lambda event, palette=button_color_palette, tooltip_send = tooltip: on_hover(event, palette, tooltip_send))
        flashcard_buttons[f"{i}_button_temporary"].bind('<Leave>', lambda event, palette=button_color_palette: on_default(event, palette))

        flashcard_buttons[f"{i}_move_forward_temporary"] = tk.Button(flashcard_buttons[f"{i}_frame_temporary"], text = "↓", width=2, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="center", relief="flat", bd=0, command=lambda item_send = item, forward = True: rearrange_items(current_file_path, item_send, forward), bg = background, fg = foreground)
        flashcard_buttons[f"{i}_move_forward_temporary"].grid(row = 0, column = 1, pady=1, padx=1, sticky = "nswe")

        flashcard_buttons[f"{i}_move_forward_temporary"].bind("<Enter>", lambda event, palette = button_color_palette, tooltip_send = "Move down": on_hover(event, palette, tooltip_send))
        flashcard_buttons[f"{i}_move_forward_temporary"].bind('<Leave>', lambda event, palette = button_color_palette: on_default(event, palette))
        #move_forward_button.bind("<Button-1>", lambda: print("Button clicked"))
        
        flashcard_buttons[f"{i}_move_backward_temporary"] = tk.Button(flashcard_buttons[f"{i}_frame_temporary"], text = "↑", width=2, height=1, wraplength=750, font=(app_settings['font'], app_settings['font_size']), anchor="center", relief="flat", bd=0, command=lambda item_send = item, forward = False: rearrange_items(current_file_path, item_send, forward), bg = background, fg = foreground)
        flashcard_buttons[f"{i}_move_backward_temporary"].grid(row = 0, column = 2, pady=1, padx=1, sticky = "nswe")

        flashcard_buttons[f"{i}_move_backward_temporary"].bind("<Enter>", lambda event, palette = button_color_palette, tooltip_send = "Move up": on_hover(event, palette, tooltip_send))
        flashcard_buttons[f"{i}_move_backward_temporary"].bind('<Leave>', lambda event, palette = button_color_palette: on_default(event, palette))

        temporary_frame.lift()
        scrollable_frame.after(50, scrollable_frame.destroy)
        scrollable_frame = temporary_frame"""

    for i, item in enumerate(items):
        print(f"loading item {i}")
        generate_widgets(i, item)

    def rearrange_items(selected_file_path, selected_item, forward):
        nonlocal scrollable_frame, flashcard_buttons
        print("Rearrange items")
        match = re.match(r'^(-?\d+)[-_ ](.+)$', selected_item)
        if match:
            selected_index = match.group(1)
            selected_clean_name = match.group(2)
            selected_index_int = int(selected_index)

        print(f"Selected item: {selected_clean_name}")
        print(f"selected index: {selected_index}")

        preceding_index = None
        preceding_index_int = None
        preceding_clean_name = None
        preceding_item = None
        preceding_serial_order = None
        next_index = None
        next_index_int = None
        next_clean_name = None
        next_item = None
        next_serial_order = None
        selected_serial_order = None
        
        items.sort()

        for serial_order, item in enumerate(items):
            match = re.match(r'^(-?\d+)[-_ ](.+)$', item) # separate file's indexing prefix with its file name
            if match:
                order = match.group(1)
                clean_name = match.group(2)
                order_int = int(order)

                print(f"Item: {item}, Order: {order}")

                if order_int > selected_index_int:
                    if next_index == None:
                        next_index = order
                        next_index_int = order_int
                        next_clean_name = clean_name
                        next_item = item
                        next_serial_order = serial_order

                elif order_int == selected_index_int:
                    selected_serial_order = serial_order
                
                elif order_int < selected_index_int:
                    preceding_index = order
                    preceding_index_int = order_int
                    preceding_clean_name = clean_name
                    preceding_item = item
                    preceding_serial_order = serial_order

            else:
                print(f"Error, could not read item: {item}")

        if current_file_path != FLASHCARDS_DIR:
            # ==== In sub-folders, a "Back" button is added to the top of the screen which can interfere with widget placement. This code blocks lets us adjust the numbers to correctly place widgets in sub-folders ====
            if preceding_serial_order != None:
                preceding_super_secret_variable = preceding_serial_order + 1
            super_secret_variable = selected_serial_order + 1
            if next_serial_order != None:
                next_super_secret_variable = next_serial_order + 1
        
        else:
            if preceding_serial_order != None:
                preceding_super_secret_variable = preceding_serial_order
            super_secret_variable = selected_serial_order
            if next_serial_order != None:
                next_super_secret_variable = next_serial_order
            
                
        print(f"Search complete. preceding index: {preceding_index}, next_index: {next_index}")

        if forward == True:
            if next_index:

                new_next_item = f"{selected_index}_{next_clean_name}"
                del items[next_serial_order]
                items.append(new_next_item)

                new_selected_item = f"{next_index}_{selected_clean_name}"
                del items[selected_serial_order]
                items.append(new_selected_item)

                items.sort()

                #flashcard_buttons[f"{selected_index}_frame"].destroy()
                #flashcard_buttons[f"{next_index_frame}"].destroy()
                #to_delete = []
                #for widget in scrollable_frame.winfo_children():
                #    to_delete.append(widget)

                #temporary_frame = tk.Frame(scrollable_frame.master, bg = widgets_color_light)
                #temporary_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
                #generate_flashcard_list()

                #temporary_frame.after(50, temporary_frame.lift())
                #scrollable_frame.after(50, scrollable_frame.destroy)
                #scrollable_frame = temporary_frame

                #scrollable_frame.after(20, lambda to_delete=to_delete: [w.destroy() for w in to_delete])


                next_item_old_path = os.path.join(selected_file_path, next_item)
                next_item_new_path = os.path.join(selected_file_path, f"{selected_index_int:06d}_{next_clean_name}")
                
                print(f"next item old path: {next_item_old_path}")
                print(f"next item new path: {next_item_new_path}")

                selected_item_old_path = os.path.join(selected_file_path, selected_item)
                selected_item_new_path = os.path.join(selected_file_path, f"{next_index_int:06d}_{selected_clean_name}")

                print(f"selected item old path: {selected_item_old_path}")
                print(f"selected item new path: {selected_item_new_path}")
                os.rename(next_item_old_path, next_item_new_path)
                os.rename(selected_item_old_path, selected_item_new_path)

                for j, item in enumerate(items):
                    if j == selected_serial_order:
                        print("j matches selected index")
                        flashcard_buttons[f"{super_secret_variable}_frame"].destroy()

                        generate_widgets(super_secret_variable, item)

                    if j == next_serial_order:
                        print("j matches next index")
                        flashcard_buttons[f"{next_super_secret_variable}_frame"].destroy()

                        generate_widgets(next_super_secret_variable, item)
                #to_delete = []
                #for widget in scrollable_frame.winfo_children(): # repeated lines of code are intentional, don't remove
                #    to_delete.append(widget)
                #generate_flashcard_list()

                #scrollable_frame.after(20, lambda: [w.destroy() for w in to_delete])

                print(f"Completed shuffle, moved {selected_clean_name} from {selected_index} to {next_index}")

        else:
            if preceding_index:

                new_selected_item = f"{preceding_index}_{selected_clean_name}"
                del items[selected_serial_order]
                items.append(new_selected_item)

                new_preceding_item = f"{selected_index}_{preceding_clean_name}"
                del items[preceding_serial_order]
                items.append(new_preceding_item)

                items.sort()

                preceding_item_old_path = os.path.join(selected_file_path, preceding_item)
                preceding_item_new_path = os.path.join(selected_file_path, f"{selected_index_int:06d}_{preceding_clean_name}")

                print(f"preceding item old path: {preceding_item_old_path}")
                print(f"preceding item new path: {preceding_item_new_path}")

                selected_item_old_path = os.path.join(selected_file_path, selected_item)
                selected_item_new_path = os.path.join(selected_file_path, f"{preceding_index_int:06d}_{selected_clean_name}")

                print(f"selected item old path: {selected_item_old_path}")
                print(f"selected item new path: {selected_item_new_path}")

                os.rename(preceding_item_old_path, preceding_item_new_path)
                os.rename(selected_item_old_path, selected_item_new_path)

                for j, item in enumerate(items):
                    if j == selected_serial_order:
                        print("j matches selected index")
                        #for widget in flashcard_buttons[f"{super_secret_variable}_frame"].winfo_children():
                        #    widget.destroy
                        flashcard_buttons[f"{super_secret_variable}_frame"].destroy()

                        generate_widgets(super_secret_variable, item)

                    if j == preceding_serial_order:
                        print("j matches next index")
                        flashcard_buttons[f"{preceding_super_secret_variable}_frame"].destroy()

                        generate_widgets(preceding_super_secret_variable, item)

                print(f"Completed shuffle, moved {selected_clean_name} from {selected_index} to {preceding_index}")

    return

        
def flashcard_set_overview(item_send, entered_from_stats_page = False):
    print("Choose study mode")
    clear_content()

    title = os.path.basename(item_send)
    flashcard_counter = []
    statistics = []
    last_studied = None
    last_grade = None
    date_english = None

    content_frame.config(bg = widgets_color_medium)

    def return_to_last_page():
        global current_file_path
        if entered_from_stats_page == True:
            stats_clicked()
        else:
            flashcards_clicked(current_file_path)

    # ==== Find how many entries are in this deck ====
    with open(item_send, 'r', encoding='utf-8') as file:
        handling = file.readlines()

    for item in handling:
        print(f"File opened: {handling}")
        if item != "\n":
            flashcard_counter.append(item)
    # ==== get clean deck name ====
    print(f" Item sent to Flashcard Overview: {item_send}")
    match = re.search(r'(-?\d+)[_ -](.+)', item_send)
    if match:
        name = match.group(2)
        name_clean = os.path.splitext(name)[0]  # Remove extension
    else:
        name = os.path.basename(item_send)
        name_clean = os.path.splitext(name) # if no match found (unlikely) just display file name

    print(f"Mark Z: name clean = {name_clean}")

    # ==== Check when this deck was last studied, and how many rounds it took ====

    try:
        if os.path.exists(STATS_FILE):
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                
                for line in lines:
                    line = line.strip()
                    if line:
                        match
                        statistics.append(eval(line))
            
            print(f"Statistics: {statistics}")
    except Exception as e:
        print(f"Error: {e}")
        statistics = []

    if statistics:
        statistics.sort()
        print("looking for latest study data on this deck")
        for tuple in reversed(statistics):
            date = tuple[0]
            deck_name = tuple[1]
            grade = tuple[2]

            if f"{deck_name}" == f"{name_clean}":
                print(f"Statistics found. Date: {date}, Grade: {grade}, Deck name: {deck_name}")
                last_studied = date

                match_date = re.match(r"(\d+), (\d+), (\d+)", date)
                if match_date:

                    last_year = match_date.group(1)
                    print(f"Last year: {last_year}")
                    last_month = match_date.group(2)
                    print(f"Last month: {last_month}")
                    last_day = match_date.group(3)
                    print(f"Last day: {last_day}")
                
                    months_english = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                    month_index = (int(last_month))
                    last_month = months_english[month_index]
                    date_english = f"{last_month} {last_day}, {last_year}"

                else:
                    date_english = date

                last_grade = grade

                print(f"Translated date to English: {date_english}")
                break
    else:
        print("Error. No statistics found")
    
    # ==== setup functions
    def export_deck():
        if system == "Windows":
            #Windows
            subprocess.run(['explorer', item_send])
        elif system =="Darwin":
            # Mac
            subprocess.run(['open', item_send])
        else:
           # Linux
           subprocess.run(['xdg-open', item_send])

    # ==== Create widgets ====
    match = re.search(r'(-?\d+)[_ -](.+)', title)
    if match:
        display_title = match.group(2)
        display_title_no_ext = os.path.splitext(display_title)[0]  # Remove extension
    else:
        display_title_no_ext = os.path.splitext(title)[0] # if no match found (unlikely) just display file name

    print(f"Mark R: display title = {display_title_no_ext}")

    back_button = tk.Button(content_frame, text = "Back", relief="raised", width = 11, height = 1, pady=4, padx=4, command = lambda: return_to_last_page(), font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    back_button.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "nw")
    back_button.bind("<Enter>", lambda event, tooltip_send = "Go back": on_hover(event, "light", tooltip_send))
    back_button.bind("<Leave>", lambda event: on_default(event, "light"))

    title_box = tk.Label(content_frame, text = display_title_no_ext, relief="sunken", width = 40, height = 1, state="normal", pady=4, padx=4, 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    title_box.grid(row = 1, column = 0, columnspan = 3, sticky = "we", padx = 40, pady = 16)

    content_frame.columnconfigure(0, weight = 1)
    content_frame.columnconfigure(1, minsize = 144, weight = 0)
    content_frame.columnconfigure(2, weight = 1)

    number_of_items_box = tk.Label(content_frame, text = f"{len(flashcard_counter)} cards", relief="flat", width = 30, height = 1, state="normal", pady=4, padx=4, 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text)
    number_of_items_box.grid(row = 2, column = 0, columnspan = 3)

    if date_english != None:
        if last_grade != None:
            last_studied_box = tk.Label(content_frame, text = f"Last studied on {date_english}              ({last_grade} Rounds)", relief="flat", width = 56, height = 1, state="normal", pady=4, padx=4, 
                            font=(app_settings['font'], app_settings['font_size']), justify = "right", bg = widgets_color_medium, fg = widgets_color_text)
            last_studied_box.grid(row = 3, column = 0, columnspan = 3)
            #last_grade_box = tk.Label(content_frame, text = f"({last_grade})", relief="flat", width = 30, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4, 
            #                font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = "pink", fg = widgets_color_text)
            #last_grade_box.grid(row = 2, column = 1, sticky = "w")

    edit_button = tk.Button(content_frame, text = "Edit", width = 15, height = 1, state="normal", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda path_send = item_send: create_new_flashcards(path_send))
    edit_button.grid(row = 5, column = 0, pady = 3, sticky = "e")

    edit_button.bind("<Enter>", lambda event, tooltip_send = "Edit this deck": on_hover(event, "light", tooltip_send))
    edit_button.bind("<Leave>", lambda event: on_default(event, "light"))

    export_button = tk.Button(content_frame, text = "Export", width = 15, height = 1, state="normal", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: export_deck())
    export_button.grid(row = 5, column = 2, pady = 3, sticky = "w")

    export_button.bind("<Enter>", lambda event, tooltip_send = "Export to other program": on_hover(event, "light", tooltip_send))
    export_button.bind("<Leave>", lambda event: on_default(event, "light"))

    write_button = tk.Button(content_frame, text = "Write mode", width = 15, height = 1, state="normal", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: study_mode(item_send))
    write_button.grid(row = 4, column = 2, pady = (44, 3), sticky = "w")

    write_button.bind("<Enter>", lambda event, tooltip_send = "Study this deck in write mode": on_hover(event, "light", tooltip_send))
    write_button.bind("<Leave>", lambda event: on_default(event, "light"))

    reveal_button = tk.Button(content_frame, text = "Reveal mode", width = 15, height = 1, state="normal", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda mode = "reveal": study_mode(item_send, mode))
    reveal_button.grid(row = 4, column = 0, pady = (44, 3), sticky = "e")

    reveal_button.bind("<Enter>", lambda event, tooltip_send = "Study this deck in reveal mode": on_hover(event, "light", tooltip_send))
    reveal_button.bind("<Leave>", lambda event: on_default(event, "light"))

def study_mode(item_send, mode = "write"):
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    print(f"Study mode begin: {item_send}")
    #prepare variables that cross-talk between functions
    global must_study, studied, app_settings, content_frame, current_file_path # use global variable so that study progress can be saved, at least within the session
    round_number = 0
    active_item = None
    clear_content()
    flashcard_set = item_send
    prompt = None
    answer = None
    response = None
    response_clean = None
    answer_display = None
    answer_clean = None
    image_path = None
    matcher = None
    end_of_session_scrollbar = None
    fade_fast_feedback_widgets_start_time = None
    timer_start_time = None
    timer_active = False
    start_of_session = True
    
    # prepare widgets
    #prompt_response_frame = tk.Frame(content_frame, bg = widgets_color_light)
    content_frame.config(bg = widgets_color_medium)
    content_frame.columnconfigure(5, weight = 1)
    content_frame.rowconfigure(0, minsize = 65)
    content_frame.rowconfigure(1, minsize = 65)
    content_frame.rowconfigure(2, minsize = 65)
    content_frame.rowconfigure(3, minsize = 65)
    content_frame.columnconfigure(1, minsize = 175, weight = 0)
    prompt_frame_border = tk.Frame(content_frame, bg = widgets_color_medium) #EBDDD1
    prompt_frame_border.grid(row = 4, column = 0, columnspan = 7, sticky = "nsew") #pack(fill = "both", expand = True, padx = 10, pady = (150, 10))
    prompt_frame = tk.Frame(prompt_frame_border, bg = widgets_color_light, width = 450, height = 400, padx = 4, pady = 4)
    prompt_frame.pack(fill = "both", anchor = "center", padx = (10, 10))
    prompt_frame.columnconfigure(0, minsize = 50)
    prompt_frame.columnconfigure(1, minsize = 250, weight = 1)
    prompt_frame.columnconfigure(2, minsize = 36)

    timer_canvas = tk.Canvas(prompt_frame, width=34, height=34, highlightthickness=0, bg = widgets_color_light)
    timer_canvas.grid(row = 0, column = 2, sticky = "nw") # this element gets used later
    #timer_canvas.pack(side = 'right')
    #timer_canvas.place(relx=0.7, rely=0.3, anchor='center')

    prompt_box = tk.Label(prompt_frame, text = "Lorem Ipsum", justify = "left", relief="sunken", state="disabled", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), anchor = "w", bg = widgets_color_light, fg = widgets_color_text)
    prompt_box.grid(row = 0, column = 1, sticky = "nsew")

    #override_incorrect_button = tk.Button(prompt_frame, text = f"Override: Incorrect ({app_settings['override_incorrect']})", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: override_incorrect_answer())
    #override_correct_button = tk.Button(prompt_frame, text = f"Override: Correct ({app_settings['override_correct']})", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: override_correct_answer())
    override_correct_button = None
    override_incorrect_button = None
    i_knew_this_button = None
    i_did_not_know_this_button = None
    show_answer_button = None

    fast_feedback_frame = None
    fast_feedback_box = None
    correct_answer_box = None
    fast_corrections_box = None
    you_said_you_said_box = None
    fast_you_said_box = None

    def edit_item():
        print("edit item")

        edit_item_frame = tk.Frame(prompt_frame_border, bg = widgets_color_light, width = 450, height = 400, padx = 4, pady = 4)
        edit_item_frame.pack(fill = "both", anchor = "center", pady = 4, padx = (10, 10))
        edit_item_frame.columnconfigure(0, minsize = 50)
        edit_item_frame.columnconfigure(1, minsize = 250)
        edit_item_frame.columnconfigure(2, minsize = 36, weight = 1)

        def close_editor():
            nonlocal save_button, cancel_button
            edit_item_frame.pack_forget()
            edit_box.config(command = lambda: edit_item())
            prompt_frame.pack(fill = "both", anchor = "center", padx = (10, 10))
            save_button.destroy()
            cancel_button.destroy()

        def save_edit():
            nonlocal active_item
            updated_prompt = edit_prompt_box.get("1.0", "end-1c")
            updated_answer = edit_answer_box.get("1.0", "end-1c")
            updated_item = f"{updated_answer}\t{updated_prompt}\n"

            print("save edit")
            with open(flashcard_set, 'r', encoding='utf-8') as file:
                handling = file.readlines()

                print(f"File opened: {handling}")

            with open(flashcard_set, 'w', encoding = 'utf-8') as f:
                for item in handling:
                    if item != "\n":
                        print(f"Processing item: {item}")
                        if item == active_item:
                            item = updated_item
                            print(f"Flashcard successfully edited: {item}")

                        f.write(f"{item}")
            
            active_item = updated_item
            print("close editor")
            close_editor()
            globals()[f"round_{round_number}_must_study"][0] = updated_item
            next_study_item()

            #handle_override_incorrect_answer()

        edit_box.config(command = lambda: close_editor())

        prompt_frame.pack_forget()
        
        response_box.grid(row = 2, column = 1)
        root.unbind(f"<Key-{app_settings['override_correct']}>")
        root.unbind(f"<Key-{app_settings['override_incorrect']}>")
        you_said_box.config(text = "")
        you_said_box.grid(row = 0, column = 0, columnspan = 1)
        prompt_box.config(text = prompt)
        feedback_box.config(text="")
        corrections_box.config(state="normal",)
        corrections_box.delete("1.0", "end")
        corrections_box.config(state = "disabled")
        corrections_box.grid(row = 0 , column = 0, columnspan = 1)
        corrections_box_2.config(text="", fg = widgets_color_text)
        corrections_box_2.grid(row = 0, column = 0, columnspan = 1)

        #edit_box.grid(row = 0, column = 0)
        
        edit_prompt_label = tk.Label(edit_item_frame, text = "Edit prompt:", padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray")
        edit_prompt_label.grid(row = 0, column = 0, rowspan = app_settings["answer_box_size"], columnspan = 2, sticky = "nsw")


        prompt_sizer = tk.Label(edit_item_frame, text = prompt, justify = "left", relief="sunken", state="disabled", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), anchor = "w", bg = widgets_color_light, fg = widgets_color_text)
        prompt_sizer.grid(row = 1, column = 1, sticky = "nsew")
        edit_prompt_box = tk.Text(edit_item_frame, relief="sunken", width = 16, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4, 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
        edit_prompt_box.grid(row = 1, column = 1, rowspan = app_settings["answer_box_size"], columnspan = 2, sticky = "nsew")
        edit_prompt_box.insert("1.0", prompt)

        edit_response_label = tk.Label(edit_item_frame, text = "Edit answer:", padx=4, 
            font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray")
        edit_response_label.grid(row = 2, column = 0, columnspan = 2, sticky = "nsw")

        answer_sizer = tk.Label(edit_item_frame, text = answer, justify = "left", relief="sunken", state="disabled", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), anchor = "w", bg = widgets_color_light, fg = widgets_color_text)
        answer_sizer.grid(row = 3, column = 1, sticky = "nsew")
        edit_answer_box = tk.Text(edit_item_frame, relief="sunken", width = 16, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4, 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
        edit_answer_box.grid(row = 3, column = 1, rowspan = app_settings["answer_box_size"], columnspan = 2, sticky = "nsew")
        edit_answer_box.insert("1.0", answer)

        frame_width = content_frame.winfo_width()
        print(f"frame width: {frame_width}")
        wrap_width = int(frame_width) - 126
        if wrap_width > 200:
            prompt_sizer.config(wraplength = wrap_width)
            answer_sizer.config(wraplength = wrap_width)

        save_button = tk.Button(edit_item_frame, text = "Save", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: save_edit())
        save_button.grid(row = 4, column = 1, sticky = "e", pady = 5)
        save_button.bind("<Enter>", lambda event, tooltip_send = "Save changes": on_hover(event, "light", tooltip_send))
        save_button.bind("<Leave>", lambda event: on_default(event, "light"))

        cancel_button = tk.Button(edit_item_frame, text = "Cancel", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda: close_editor())
        cancel_button.grid(row = 4, column = 1, sticky = "w", pady = 5)
        cancel_button.bind("<Enter>", lambda event, tooltip_send = "Cancel": on_hover(event, "light", tooltip_send))
        cancel_button.bind("<Leave>", lambda event: on_default(event, "light"))


    edit_box = tk.Button(content_frame, text = "✎", relief="raised",
                    font=(app_settings['font'], app_settings['font_size']), anchor = "w", bg = widgets_color_light, fg = widgets_color_text, command = lambda: edit_item())
    edit_box.grid(row = 3, column = 6, padx = 10, pady = 4) #place(relx = 1, x = -20, y = 110, anchor = "ne")
    edit_box.bind("<Enter>", lambda event, tooltip_send = "Edit this item": on_hover(event, "light", tooltip_send))
    edit_box.bind("<Leave>", lambda event: on_default(event, "light"))

    response_box = tk.Text(prompt_frame, relief="sunken", width = 16, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4, 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    response_box.grid(row = 2, column = 1, rowspan = app_settings["answer_box_size"], columnspan = 2, sticky = "nsew")
    you_said_box = tk.Label(prompt_frame, relief = "flat", font=({app_settings['font']}, app_settings['font_size']), bg = widgets_color_light, fg = "gray")
    you_said_box.grid(row = 0, column = 0, columnspan = 1, sticky = "w")

    feedback_box = tk.Label(prompt_frame, text="", relief = "flat", pady=4, padx=4, font=({app_settings['font']}, 18), bg = widgets_color_light, fg = "green")
    feedback_box.grid(row = 1, column = 1)

    image_label = None

    #corrections_frame = tk.Frame(content_frame, bg = widgets_color_light)
    #corrections_frame.place(relx=0.5, rely=0.4, y=36, x=-73, anchor = 'center')
    corrections_box = tk.Text(prompt_frame, relief="flat", width= 1, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4,
                font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    corrections_box.grid(row = 0, column = 0, rowspan = app_settings["answer_box_size"], columnspan = 2, sticky = "nsew")
    corrections_box_2 = tk.Label(prompt_frame, text="", relief="flat", state="normal", pady=4, padx=4, 
                font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    corrections_box_2.grid(row = 0, column = 0, columnspan = 1, sticky = "w")

    # ==== Progress bar widgets ====
    bar_frame_border = tk.Frame(content_frame, bg = navigation_color_buttons, padx = 5, pady = 5)
    bar_frame = tk.Frame(bar_frame_border, width = 175, height = 175, bg = widgets_color_light, padx = 10, pady = 10)
    
    total_total_bar = tk.Canvas(bar_frame, width = 150, height = 15, highlightthickness=0, bg = "lightgray")
    total_incorrect_bar = tk.Canvas(bar_frame, width = 0, height = 15, highlightthickness=0, bg = "red3")
    total_correct_bar = tk.Canvas(bar_frame, width = 0, height = 15, highlightthickness=0, bg = "green4")
    total_bar_label = tk.Label(bar_frame, text=f"", relief = "flat", font=({app_settings['font']}, app_settings['font_size']), bg = widgets_color_light, fg = "gray")

    current_round_total_bar = tk.Canvas(bar_frame, width = 150, height = 15, highlightthickness=0, bg = "lightgray")
    current_round_incorrect_bar = tk.Canvas(bar_frame, width = 0, height = 15, highlightthickness=0, bg = "red3")
    current_round_correct_bar = tk.Canvas(bar_frame, width = 0, height = 15, highlightthickness=0, bg = "green4")
    current_round_bar_label = tk.Label(bar_frame, text=f"", relief = "flat", font=({app_settings['font']}, app_settings['font_size']), bg = widgets_color_light, fg = "gray")

    # ==== End of round widgets ====
    end_of_round_frame = tk.Frame(main_area, bg = widgets_color_medium)
    end_of_round_frame.pack_forget()

    end_of_round_frame_inner_frame = tk.Frame(end_of_round_frame, bg = widgets_color_medium)
    end_of_round_frame_inner_frame.place(relx=0.5, rely=0.4, anchor="center")

    end_of_round_box = tk.Label(end_of_round_frame_inner_frame, text="", font=({app_settings['font']}, 28), fg = "gray", bg = widgets_color_medium)
    end_of_round_box.grid(row = 0, column = 0) #place(relx=0.5, rely=0.4, anchor="center")
    round_statistics_box = tk.Label(end_of_round_frame_inner_frame, text="", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_medium)
    round_statistics_box.grid(row = 1, column = 0) #place(relx=0.5, rely=0.45, anchor="center") 
    round_statistics_box2 = tk.Label(end_of_round_frame_inner_frame, text="", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_medium)
    round_statistics_box2.grid(row = 2, column = 0) #place(relx=0.5, rely=0.5, anchor="center")
    round_statistics_box3 = tk.Label(end_of_round_frame_inner_frame, text="", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_medium)
    round_statistics_box3.grid(row = 3, column = 0) #place(relx=0.5, rely=0.55, anchor="center")

    # ==== End of session widgets ====
    end_of_session_frame = tk.Frame(main_area, bg = widgets_color_light)
    end_of_session_frame.pack_forget()
    
    # ==== Sub-functions ====
    def next_study_item():
        nonlocal prompt, answer, answer_clean, response, response_clean
        nonlocal image_path, image_label
        nonlocal active_item
        nonlocal round_number, override_correct_button, override_incorrect_button, i_knew_this_button, i_did_not_know_this_button, show_answer_button
        nonlocal prompt_box
        nonlocal timer_start_time
        nonlocal start_of_session
        global tooltip_tracker, tooltip_holder
        tooltip_tracker = False
        try:
            tooltip_holder.destroy()
            tooltip_holder = None
        except:
            tooltip_holder = None

        print("Mark 6: Next study item")
        print(f"Remaining study items: {len(globals().get(f'round_{round_number}_must_study', []))}")
        print(f"Correct study items: {len(globals().get(f'round_{round_number}_correct', []))}")
        print(f"{round_number}")
        print(f"Incorrect study items: {len(globals().get(f'round_{round_number}_incorrect', []))}")

        """
        if not globals().get(f"round_{round_number}_must_study)", []):
            print("attempt to start next round")
            next_round
        
        else:
            active_item = globals() [f"round_{round_number}_must_study"][0]
        """
        active_item = None  # or some default value
        if not globals().get(f"round_{round_number}_must_study", []):
            active_item = None  # or some default value
            print("attempt to start next round")
            next_round()
        try:
            active_item = globals()[f"round_{round_number}_must_study"][0]
        except:
            return "break"

        if active_item != None:
            progress_bars()
            start_of_session = False
            
            print(f"length of study list: {len(globals() [f"round_{round_number}_must_study"])} (Round {round_number})")
            print(f"active item: {active_item}")
            match = re.match(r'^(.*?)\t(.*?)(?:\t(.*))?$', active_item)
            if match:
                if app_settings["reverse_term_and_definition"] == True:
                    prompt = match.group(1)
                    answer = match.group(2)
                    image_path = match.group(3) if match.group(3) else None
                else:
                    prompt = match.group(2)
                    answer = match.group(1)
                    image_path = match.group(3) if match.group(3) else None

            else:
                print("Error, could not read deck")
                end_of_round_frame.pack_forget()
                end_of_session_frame.pack_forget()
                content_frame.pack(fill="both", expand=True, padx=10, pady=10)
                prompt_box.config(text = "Error, could not read deck.")
                root.unbind("<Return>")
                response_box.unbind("<Return>")
                root.unbind(f"<Key-{app_settings['override_incorrect']}>")
                root.unbind(f"<Key-{app_settings['override_incorrect']}>")
                #root.bind("<Return>", lambda path = flashcard_set: create_new_flashcards(path))

                edit_button = tk.Button(prompt_frame, text = "Error reading deck. Click to open in edit mode", width = 44, height = app_settings["answer_box_size"], state="normal", pady=4, padx=4,
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, command = lambda path_send = flashcard_set: create_new_flashcards(path_send))
                edit_button.grid(row = 3, column = 1, pady = 8, padx = 4)
                edit_button.bind("<Enter>", lambda event, theme = "light", tooltip = "Edit this deck": on_hover(event, theme, tooltip))
                edit_button.bind("<Leave>", lambda event, theme = "light": on_default(event, theme))

                return "break"

            print(f"Successfully read next flashcard pair. Prompt: {prompt}, Answer: {answer}, Image: {image_path}")

            if image_label:
                image_label.destroy()
                image_label = None

            if image_path:
                print(f"Image found: {image_path}")

                # Load and convert the image

                # ==== Image path may be abbreviated (images within the 'MonarchFlashcards' file get abbreviated to allow easier sharing between users) ====
                if os.path.isabs(image_path):
                    # It's already an absolute path
                    if os.path.exists(image_path):
                        img = Image.open(image_path)
                    else:
                        img = None
                else:
                    # It's a relative path - combine with DATA_DIR
                    full_path = os.path.join(DATA_DIR, image_path)
                    if os.path.exists(full_path):
                        img = Image.open(full_path)
                    else:
                        img = None

                if img:
                    img.thumbnail((512, 256))
                    photo = ImageTk.PhotoImage(img)

                    # Create a label to display it
                    image_label = tk.Label(content_frame, image=photo)
                    image_label.image = photo  # Keep a reference!
                    image_label.grid(row=0, column=3, columnspan = 1, rowspan = 4, sticky = "nw", padx = 10, pady = 10)

            if app_settings['timer'] == True:
            #timer_canvas = tk.Canvas(content_frame, width=100, height=100, highlightthickness=0, bg = widgets_color_light)
            #containter.pack(side=left, padx=10)
            #timer_canvas.place(relx=0.7, rely=0.3, anchor='center')

            # Draw the initial full pie (green circle)
            #timer_canvas.create_oval(5, 5, 45, 45, fill="green", outline="lightgreen")
                timer_start_time = time.time()
                start_timer(answer, timer_start_time)

            end_of_round_frame.pack_forget()
            end_of_session_frame.pack_forget()
            content_frame.pack(fill="both", expand=True, padx=10, pady=10)
            you_said_box.config(text = "")
            you_said_box.grid(row = 0, column = 0, columnspan = 1)
            prompt_box.config(text = prompt)
            feedback_box.config(text="")
            corrections_box.config(state="normal",)
            corrections_box.delete("1.0", "end")
            corrections_box.config(state = "disabled")
            corrections_box.grid(row = 0 , column = 0, columnspan = 1)
            corrections_box_2.config(text="", fg = widgets_color_text)
            corrections_box_2.grid(row = 0, column = 0, columnspan = 1)
            if override_correct_button:
                override_correct_button.destroy()
                override_correct_button = None
            if override_incorrect_button:
                override_incorrect_button.destroy()
                override_incorrect_button = None

            #resize_widgets()
            #edit_box.grid(row = 0, column = 0)

            print("Mark 7 - bind <return> to submit answer")

            if mode == "write":
                response_box.config(state="normal", fg = widgets_color_text)
                response_box.delete("1.0", "end")
                response_box.grid(row = 2, column = 1)
                root.unbind(f"<Key-{app_settings['override_correct']}>")
                root.unbind(f"<Key-{app_settings['override_incorrect']}>")

                root.unbind("<Return>")
                root.unbind("<space>")
                response_box.bind("<Return>", lambda event: check_answer())
            
            elif mode == "reveal":
                response_box.config(state="normal", fg = widgets_color_text)
                response_box.delete("1.0", "end")
                response_box.config(state="disabled")
                root.unbind(f"<Key-{app_settings['override_correct']}>")
                root.unbind(f"<Key-{app_settings['override_incorrect']}>")

                root.bind("<Return>", lambda event: check_answer())
                root.bind("<space>", lambda event: check_answer())

                show_answer_button = tk.Button(content_frame, text = "Show answer", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, width = 30, relief = "raised", command = lambda: check_answer())
                show_answer_button.grid(row = 8, column = 0, columnspan = 7, padx = 50, pady = 10, sticky = "we") #place(x = 200, y = 375)
                show_answer_button.bind("<Enter>", lambda event, theme = "light", tooltip = "Press space or click this button to reveal answer": on_hover(event, theme, tooltip))
                show_answer_button.bind("<Leave>", lambda event, theme = "light": on_default(event, theme))

                if i_knew_this_button:
                    i_knew_this_button.destroy()
                    i_knew_this_button = None
                if i_did_not_know_this_button:
                    i_did_not_know_this_button.destroy()
                    i_did_not_know_this_button = None

            return "break"

        frame_width = content_frame.winfo_width()
        print(f"frame width: {frame_width}")
        wrap_width = int(frame_width) - 126
        if wrap_width > 200:
            prompt_box.config(wraplength = wrap_width)

    def start_over():
        nonlocal round_number
        to_delete = []
        for name, obj in globals().items():
            if isinstance(obj, (list, set)) and name.startswith("round"):
                to_delete.append(name)

        for name in to_delete:
            print(f"deleting: {name}")
            del globals()[name]

        try:

            for widget in end_of_round_frame.winfo_children():
                widget.destroy()
        except:
            print("dummy text")

        #end_of_session_scrollbar == None
        
        round_number = 0

        study_mode(flashcard_set, mode)

        return

    def next_round(): #
        nonlocal round_number, start_of_session
        print("Mark 1: next round")
        # ==== Check what round we're in ====
        round_number_finder = []
        for name, obj in globals().items():
            print(f"{name}")
            if name.startswith("round"):
                round_number_finder.append(name)
        for item_name in round_number_finder:
            match = re.match(r'round_(\d+)_', item_name)  # regex pattern that finds numbers
            if match:
                number_string = match.group(1)
                number = int(number_string)
                if number > round_number: # look for highest number in rounds list to determine which round we're on
                    round_number = number
        print(f"Mark 1.1: round_number detected: {round_number}")
        # ==== Check if saved study progress matches the selected flashcard set ====
        try:
            must_study_cards = globals().get(f"round_{round_number}_must_study", [])
            correct_cards = globals().get(f"round_{round_number}_correct", [])
            incorrect_cards = globals().get(f"round_{round_number}_incorrect", [])

            print(f"must study cards: {must_study_cards}")
            print(f"correct cards: {correct_cards}")
            print(f"incorrect cards: {incorrect_cards}")

            combined_cards = []

            combined_cards.extend(must_study_cards)
            combined_cards.extend(correct_cards)
            combined_cards.extend(incorrect_cards)
        
        except:
            combined_cards = []
        print("Mark 1.2: Short-term-memory has been read")
        print(f"Combined cards: {combined_cards}")
        if not combined_cards == []: # if there is any saved study progress
            print("Mark 1.3: Study items in short term memory detected")
            with open(flashcard_set, 'r', encoding='utf-8') as file:
                handling = file.readlines() # "handling" contains items in selected flashcard set
                print(f"Handling: {handling}")

                if not set(combined_cards).issubset(set(handling)): # if saved study progress mis-matches selected flashcard set
                    print(f"Mark 2: Mismatch detected. Short-term memory: {combined_cards}")
                    print(f"Selected flashcards: {handling}")
                    to_delete = []
                    for name, obj in globals().items():
                        if isinstance(obj, (list, set)) and name.startswith("round"):
                            to_delete.append(name)

                    for name in to_delete:
                        print(f"deleting: {name}")
                        del globals()[name]
                    
                    round_number = 0

        if combined_cards == []:
            round_number = 0

        next_round_number = round_number + 1
        def create_next_lists():
            # ==== Generate the lists that will handle study items ====
            print("Mark 3: generate lists for next round")
            globals()[f"round_{next_round_number}_must_study"] = []
            globals()[f"round_{next_round_number}_correct"] = []
            globals()[f"round_{next_round_number}_incorrect"] = []
            globals()[f"round_{next_round_number}_study_progress"] = []

        if not globals().get(f"round_{round_number}_must_study", []): # if must_study is empty, or doesn't exist, generate and populate next (or first) round's lists        
            if round_number == 0:  # generate first round of lists
                create_next_lists()
                print("Mark 4: populate first round of lists with flashcard items")
                with open(flashcard_set, 'r', encoding='utf-8') as file:
                    handling2 = file.readlines()

                    if not handling2: # if user opens empty file
                        print("No flashcards found in file")
                        clear_content()
                        error_message = tk.Label(content_frame, text = "Error: The selected deck appears to have no flashcards")
                        error_message.grid(row = 0, column = 0)
                        edit_deck_button = tk.Button(content_frame, text = "Edit this deck", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, height = 1, width = 15, relief = "raised", command = lambda path = flashcard_set: create_new_flashcards(path))
                        edit_deck_button.grid(row = 1, column = 0)
                        edit_deck_button.bind("<Enter>", lambda event, tooltip_send = "Edit this deck": on_hover(event, "light", tooltip_send))
                        edit_deck_button.bind("<Leave>", lambda event: on_default(event, "light"))

                        select_other_set_button = tk.Button(content_frame, text = "Select another deck", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, height = 1, width = 15, relief = "raised", command = lambda path = current_file_path: flashcards_clicked(path))
                        select_other_set_button.grid(row = 2, column = 0)
                        select_other_set_button.bind("<Enter>", lambda event, tooltip_send = "Select another deck": on_hover(event, "light", tooltip_send))
                        select_other_set_button.bind("<Leave>", lambda event: on_default(event, "light"))
                    
                    globals()[f"round_{next_round_number}_must_study"] = handling2

            elif not globals().get(f"round_{round_number}_incorrect", []) == []:
                create_next_lists()
                print("Mark 5: Take the incorrect answers from last round and move them into the queue for next round")
                # Get the incorrect items from the previous round
                incorrect_items = globals().get(f"round_{round_number}_incorrect", [])
                for item in incorrect_items:
                    globals()[f"round_{next_round_number}_must_study"].append(item)

                if app_settings["elimination_mode"] == False:
                    correct_items = globals().get(f"round_{round_number}_correct", [])
                    for item in correct_items:
                        globals()[f"round_{next_round_number}_must_study"].append(item)

                if app_settings["quick_submit_answer"] == True:
                    next_study_item()
                else:
                    end_of_round()

                return
            
            elif globals().get("round_1_incorrect", []) == [] and globals().get("round_1_correct", []) == [] and globals().get("round_1_must_study", []) == []:
                print("empty deck loaded into memory")
                clear_content()
                error_message = tk.Label(content_frame, text = "Error: Empty deck loaded")
                error_message.grid(row = 0, column = 0)
                edit_deck_button = tk.Button(content_frame, text = "Edit this deck", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, height = 1, width = 15, relief = "raised", command = lambda path = flashcard_set: create_new_flashcards(path))
                edit_deck_button.grid(row = 1, column = 0)
                edit_deck_button.bind("<Enter>", lambda event, tooltip_send = "Edit this deck": on_hover(event, "light", tooltip_send))
                edit_deck_button.bind("<Leave>", lambda event: on_default(event, "light"))
                
                select_other_set_button = tk.Button(content_frame, text = "Select another deck", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, height = 1, width = 15, relief = "raised", command = lambda path = current_file_path: flashcards_clicked(path))
                select_other_set_button.grid(row = 2, column = 0)
                select_other_set_button.bind("<Enter>", lambda event, tooltip_send = "Edit this deck": on_hover(event, "light", tooltip_send))
                select_other_set_button.bind("<Leave>", lambda event: on_default(event, "light"))
                return
            
            else: 
                """if not globals().get(f"round_{round_number}_must_study"):
                    if not globals().get(f"round_{round_number}_correct"):
                        if not globals().get(f"round_{round_number}_incorrect"):"""
                print("Mark 14: All items reviewed")
                if start_of_session == False:
                    end_of_study_session()
                else:
                    start_over()
                return "break"
            
            if app_settings['random_order']:
                print(f"Randomizing order of round_{next_round_number}")
                random.shuffle(globals()[f"round_{next_round_number}_must_study"])  
            round_number = next_round_number

            print("attempt to assign active round variables")
            print(f"round_{round_number}_must_study: {len(globals().get(f'round_{round_number}_must_study', []))}")


        # Must study progress (items remaining)

    def end_of_round():

        nonlocal round_statistics_box2, round_statistics_box3
        print("Mark 18: End of round")
        content_frame.pack_forget()
        print("Mark 19: hide content frame")
        end_of_round_frame.pack(side="right", fill="both", expand=True)
        print("Mark 20: create new frame")
        round_total = len(globals().get(f"round_{round_number}_must_study")) + len(globals().get(f"round_{round_number}_correct")) + len(globals().get(f"round_{round_number}_incorrect"))
        round_correct = len(globals().get(f"round_{round_number}_correct"))
        round_incorrect = len(globals().get(f"round_{round_number}_incorrect"))
        print("Mark 21: Calculate end-of-round statistics")
        end_of_round_box.config(text=f"Round {round_number}") #) = tk.Label(end_of_round_frame, text=f"Round {round_number}", font=({app_settings['font']}, 28), fg = "gray", bg = widgets_color_light)

        round_statistics_box.config(text=f"{round_total} Items") # = tk.Label(end_of_round_frame, text=f"{round_total} Items", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_light)

        round_statistics_box2.config(text=f"{round_correct} Correct") # = tk.Label(end_of_round_frame, text=f"{round_correct} Correct", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_light)

        if app_settings["elimination_mode"] == True:
            round_statistics_box3.config(text=f"{round_incorrect} Remaining") # = tk.Label(end_of_round_frame, text=f"{round_incorrect} Remaining", font=({app_settings['font']}, app_settings['font_size']), fg = "gray", bg = widgets_color_light)

        print("Mark 22: Draw statistics boxes")

        root.unbind("<Return")
        response_box.unbind("<Return>")
        #response_box.bind("<Return>", lambda event: next_round())
        root.bind("<Return>", lambda event: next_study_item())
        root.bind("<space>", lambda event: next_study_item())

        print("Mark 23: handle bindings")

        # ==== re-use show_answer_button to move on to next round (since it generally advances to the next entry normally) ====
        show_answer_button = tk.Button(end_of_round_frame_inner_frame, text = "Press ENTER to Start next round", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, width = 30, relief = "raised", command = lambda: next_study_item())
        show_answer_button.grid(row = 4, column = 0, padx = 50, pady = 10, sticky = "we") #place(x = 200, y = 375)
        show_answer_button.bind("<Enter>", lambda event, theme = "light", tooltip = "Press space or click this button to start next round": on_hover(event, theme, tooltip))
        show_answer_button.bind("<Leave>", lambda event, theme = "light": on_default(event, theme))

        return "break"

    def end_of_study_session():
        nonlocal round_number, end_of_session_frame, end_of_session_scrollbar
        print("Mark 24: End of study session")
        root.unbind("<Return>")
        response_box.config(state = "disabled")
        end_of_round_frame.pack_forget()
        clear_content()
        """
        content_frame.pack_forget()
        end_of_session_frame.pack(side="left", fill="both", expand = True)
        end_of_session_frame.columnconfigure(0, weight = 1)
        
        try: # if function is called multiple times (for example by user clicking off and back on), prevents duplicate creation of widgets (messy code, clean up later)
            clear_content()

            for widget in end_of_session_frame.winfo_children():
                widget.destroy()
        
            end_of_session_scrollbar.destroy()
            scrollbar.destroy()

            clear_content()

        except:
            print("Dummy string - Nothing to erase in end of round")
        """
        
        end_of_session_frame = tk.Frame(main_area, bg = widgets_color_light)
        end_of_session_frame.pack(side="left", fill="both", expand = True)
        content_frame.pack_forget()

        end_of_session_canvas = tk.Canvas(end_of_session_frame, bg = widgets_color_medium)
        end_of_session_canvas.pack(side = "left", fill="both", expand = True)
        statistics_frame = tk.Frame(end_of_session_canvas, bg = widgets_color_light)
        statistics_frame.pack(fill = "both", expand = True)
        statistics_frame.columnconfigure(0, weight = 1)
        canvas_window = end_of_session_canvas.create_window((0, 0), window = statistics_frame, anchor = "nw")

        def configure_scroll_region(event):
            canvas_width = event.width
            end_of_session_canvas.itemconfig(canvas_window, width=canvas_width)

        end_of_session_canvas.bind('<Configure>', configure_scroll_region)

        statistics_frame.columnconfigure(0, weight = 1)

        end_of_session_box = tk.Label(statistics_frame, text=f"Completed in {round_number} rounds", font=(app_settings['font'], 28), bg = navigation_color_buttons, fg = navigation_color_text, padx = 10, pady = 10)
        end_of_session_box.grid(row = 0, column = 0, sticky = "nsew")

        try_again = tk.Button(statistics_frame, text="Try again", width=15, height=3, font=(app_settings['font'], app_settings['font_size']), bg = navigation_color_buttons, fg = navigation_color_text, command = lambda: start_over())
        try_again.grid(row = 0, column = 1, sticky = "e")

        try_again.bind("<Enter>", lambda event, tooltip_send = "Study this deck again": on_hover(event, "dark", tooltip_send))
        try_again.bind("<Leave>", lambda event: on_default(event, "dark"))

        end_of_session_statistics = []
        frames = {}  # Dictionary to store your frames
        boxes = {}   # Dictionary to store your round labels

        frame_width = main_area.winfo_width()
        print(f"frame width: {frame_width}")
        wrap_width_2 = (int(frame_width) - 200 ) / 3
        print(f"Wrap width for end of session: {wrap_width_2}")
        if wrap_width_2 < 200:
            wrap_width_2 = 200

        for name, obj in globals().items():
            if name.endswith("_study_progress"):
                end_of_session_statistics.append(obj)

        for i, obj in enumerate(end_of_session_statistics):
            # Create frame and store in dictionary
            frames[f"round_{i}_frame"] = tk.Frame(statistics_frame, bg = widgets_color_medium, padx = 10)
            frames[f"round_{i}_frame"].grid(row=(i + 1), column=0, columnspan = 2, sticky = "nsew")  # Use grid consistently
            frames[f"round_{i}_frame"].columnconfigure(1, minsize = wrap_width_2, weight = 1)
            frames[f"round_{i}_frame"].columnconfigure(2, minsize = wrap_width_2, weight = 1)
            frames[f"round_{i}_frame"].columnconfigure(4, minsize = wrap_width_2, weight = 1)
            #EBDDD1
            # Create label and store in dictionary
            boxes[f"round_{i}_box"] = tk.Label(frames[f"round_{i}_frame"], text=f"Round {(i + 1)}", font=(app_settings['font'], 24), bg = widgets_color_medium, fg = widgets_color_text, justify = "left")
            boxes[f"round_{i}_box"].grid(row=0, column=0, columnspan = 5, sticky = "nsew")
            
            for j, (prompt, answer, response, grade) in enumerate(obj):

                background = tk.Canvas(frames[f"round_{i}_frame"], bg = widgets_color_light, height = 1, width = 1)
                background.grid(row = (j + 1), column = 0, columnspan = 5, sticky = "nsew", pady = (0,2))

                item_1 = tk.Label(frames[f"round_{i}_frame"], text = (j + 1), font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, pady = 1, padx = 10, wraplength = wrap_width_2)
                item_1.grid(row=(j + 1), column = 0, sticky = "ne", padx = (2, 0), pady = (0, 2))
                item_2 = tk.Label(frames[f"round_{i}_frame"], text = prompt, font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = widgets_color_light, fg = widgets_color_text, pady = 1, wraplength = wrap_width_2)
                item_2.grid(row = (j + 1), column = 1, sticky = "new", pady = (0, 2))
                print(f"Round {round_number}, Item 1 width = {item_2.winfo_width()}")
                item_3 = tk.Label(frames[f"round_{i}_frame"], text = answer, font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = widgets_color_light, fg = widgets_color_text, pady = 1, wraplength = wrap_width_2)
                item_3.grid(row = (j + 1), column = 2, sticky = "new", pady = (0, 2))
                print(f"Round {round_number}, Item 1 width = {item_3.winfo_width()}")
                item_4 = tk.Label(frames[f"round_{i}_frame"], text = "You said:", font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = widgets_color_light, fg = "gray", pady = 1, wraplength = wrap_width_2)
                item_4.grid(row = (j + 1), column = 3, sticky = "new", pady = (0, 2))
                item_5 = tk.Label(frames[f"round_{i}_frame"], text = f"{response} ({grade})", font=(app_settings['font'], app_settings['font_size']), justify = "left", bg = widgets_color_light, fg = widgets_color_text, pady = 1, wraplength = wrap_width_2)
                item_5.grid(row = (j + 1), column = 4, sticky = "new", padx = (0, 2), pady = (0, 2))
                
                #if grade != "Correct":
                #    item_4.config(text = "You said:", justify = "left", anchor = "w")
                #    item_5.config(text = f"{response} ({grade})", justify = "left", anchor = "w")

                if grade == "Correct" or grade == "Override: Correct" or grade == "Correct: Timed out":
                    item_2.config(fg = "green", justify = "left", anchor = "w")
                    item_3.config(fg = "green", justify = "left", anchor = "w")
                    item_5.config(fg = "green", justify = "left", anchor = "w")
                    if grade == "Override: Correct":
                        item_5.config(fg = "green", justify = "left")

                elif grade == "Incorrect" or grade == "Override: Incorrect":
                    item_2.config(fg = "red", justify = "left", anchor = "w")
                    item_3.config(fg = "red", justify = "left", anchor = "w")
                    item_5.config(fg = "red", justify = "left", anchor = "w")

                else:
                    item_2.config(fg = "gray", justify = "left", anchor = "w")
                    item_3.config(fg = "gray", justify = "left", anchor = "w")
                    item_5.config(fg = "gray", justify = "left", anchor = "w")
                
                print(f"Round {round_number}, Item 1 width = {item_4.winfo_width()}")
                print(f"Round {round_number}, Item 1 width = {item_5.winfo_width()}")

        end_of_session_scrollbar = tk.Scrollbar(main_area, orient="vertical", command=end_of_session_canvas.yview)
        end_of_session_canvas.configure(yscrollcommand=end_of_session_scrollbar.set)

        end_of_session_scrollbar.pack(side="right", fill="y")
            
        
        if system == "Windows" or system =="Darwin":
            print("setup scroll for Windows/Mac")
            def on_mousewheel(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                statistics_frame_height = statistics_frame.winfo_height()
                end_of_session_frame_height = end_of_session_frame.winfo_height()

                print(f"Statistcis frame height: {statistics_frame_height}, End of session frame height: {end_of_session_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if statistics_frame_height > end_of_session_frame_height:
                    print("attempt to scroll")
                    end_of_session_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

            root.bind("<MouseWheel>", on_mousewheel)  # Windows/Mac
        else:
            print("setup scroll for Linux")
            def on_mousewheel_linux_down(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                statistics_frame_height = statistics_frame.winfo_height()
                end_of_session_frame_height = end_of_session_frame.winfo_height()

                print(f"Statistcis frame height: {statistics_frame_height}, End of session frame height: {end_of_session_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if statistics_frame_height > end_of_session_frame_height:
                    print("attempt to scroll")
                    end_of_session_canvas.yview_scroll(-1, "units")
                else:
                    print("Could not scroll")

            def on_mousewheel_linux_up(event):
                # ==== Start with a check to see if the scrollable frame is larger than the window ====
                statistics_frame_height = statistics_frame.winfo_height()
                end_of_session_frame_height = end_of_session_frame.winfo_height()

                print(f"Statistcis frame height: {statistics_frame_height}, End of session frame height: {end_of_session_frame_height}")

                # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
                if statistics_frame_height > end_of_session_frame_height:
                    print("attempt to scroll")
                    end_of_session_canvas.yview_scroll(1, "units")
                else:
                    print("Could not scroll")

            root.bind("<Button-4>", on_mousewheel_linux_up)  # Linux
            root.bind("<Button-5>", on_mousewheel_linux_down)  # Linux

        statistics_frame.update_idletasks()  # Force layout calculation
        end_of_session_canvas.configure(scrollregion=end_of_session_canvas.bbox("all"))

        # ==== record statistics ====
        if app_settings["collect_stats"] == True: # fix name of study set (from things like 001_philosophy.txt)
            match = re.search(r'(-?\d+)[_ -](.+)', item_send)
            if match:
                display_name = match.group(2)
                display_name_no_ext = os.path.splitext(display_name)[0]  # Remove extension
            else:
                display_name = os.path.basename(item_send)
                display_name_no_ext = os.path.splitext(display_name)[0] # if no match found (unlikely) just display file name

            print(f"Mark S: deck name = {display_name_no_ext}")
    
            print("Record statistics")
            today = date.today()
            date_string = today.strftime("%Y, %m, %d")
            statistics_string = date_string, display_name_no_ext, round_number,
            print(f"statistics: {statistics_string}")

            try:
                with open(STATS_FILE, 'a', encoding='utf-8') as f:
                    f.write(f"{statistics_string}\n")
            except Exception as e:
                print(f"Error saving settings: {e}")

        """
        end_of_session_statistics = []

        for name, obj in globals().items():
            if name.endswith("_study_progress"):
                end_of_session_statistics.append(obj)

        for i, name, obj in enumerate(end_of_session_statistics):
            [f"round_{i}_frame"] = tk.Frame(end_of_session_frame, bg = "brown")
            [f"round_{i}_frame"].pack(row=(i + 1), column = 0)
            [f"round_{i}_box"] = tk.Label= [f"round_{i}_frame"], text= f"Round {(i + 1)}"
            [f"round_{i}_box"].grid(row=0, column = 0)

            for prompt, clean_answer, clean_response, grade, round in obj:
                item = tk.Label([f"round_{i}_box"], text = f"Prompt: {prompt}, Answer: {clean_answer}, You said: {clean_response} ({grade})", bg = widgets_color_light)
                item.grid(row = i, column = 1)"""

    def progress_bars(temporary = False, temporary_answer_is_correct = False):
        print(f"Calling function progress bars: {app_settings["show_progress_bars"]}")
        if app_settings["show_progress_bars"]: # == "True":

            # ==== Get number of items in the lists to build progress bars, or 0 if they haven't generated yet ====
            a = len(globals().get(f"round_1_must_study", []))
            b = len(globals().get(f"round_1_correct", []))
            c = len(globals().get(f"round_1_incorrect", []))
            ax = len(globals().get(f"round_{round_number}_must_study", []))
            bx = len(globals().get(f"round_{round_number}_correct", []))
            cx = len(globals().get(f"round_{round_number}_incorrect", []))

            total_total = a + b + c
            total_correct = total_total - ax - cx
            total_incorrect = total_total - ax # due to how the progress bars are rendered, this value actually should equal total correct + (total) incorrect

            current_round_total = ax + bx + cx
            current_round_correct = bx
            current_round_incorrect = bx + cx # due to how the progress bars are rendered, this value actually should equal correct + incorrect

            print(f"total bar: {total_correct}: {total_incorrect}: {total_total}")
            print(f"current round bar: {current_round_correct}: {current_round_incorrect}: {current_round_total}")

            if temporary == True: # temporary allows user to see immediate feedback before answer is fully locked in
                if temporary_answer_is_correct == True:
                    total_correct = total_correct + 1
                    total_incorrect = total_incorrect + 1
                    current_round_correct = current_round_correct + 1
                    current_round_incorrect = current_round_incorrect + 1
                else:
                    total_incorrect = total_incorrect + 1
                    current_round_incorrect = current_round_incorrect + 1

                print(f"After temporary alterations total bar: {total_correct}: {total_incorrect}: {total_total}")
                print(f"After temporary alterations current round bar: {current_round_correct}: {current_round_incorrect}: {current_round_total}")

            if total_total > 0:
                total_bar_coefficient = 150 / total_total
            else:
                total_bar_coefficient = 150

            if current_round_total > 0:
                current_round_bar_coefficient = 150 / current_round_total
            else:
                current_round_bar_coefficient = 150

            """
            bar_frame_border = tk.Frame(content_frame, bg = navigation_color_buttons, padx = 5, pady = 5)
            bar_frame = tk.Frame(bar_frame_border, width = 175, height = 175, bg = widgets_color_light, padx = 10, pady = 10)
            
            total_total_bar = tk.Canvas(bar_frame, width = total_total_bar_length, height = 15, highlightthickness=0, bg = "lightgray")
            total_incorrect_bar = tk.Canvas(bar_frame, width = total_incorrect_bar_length, height = 15, highlightthickness=0, bg = "red3")
            total_correct_bar = tk.Canvas(bar_frame, width = total_correct_bar_length, height = 15, highlightthickness=0, bg = "green4")
            total_bar_label = tk.Label(bar_frame, text=f"total: {total_correct}/{total_total}", relief = "flat", font=({app_settings['font']}, app_settings['font_size']), bg = widgets_color_light, fg = "gray")

            current_round_total_bar = tk.Canvas(bar_frame, width = current_round_total_bar_length, height = 15, highlightthickness=0, bg = "lightgray")
            current_round_incorrect_bar = tk.Canvas(bar_frame, width = current_round_incorrect_bar_length, height = 15, highlightthickness=0, bg = "red3")
            current_round_correct_bar = tk.Canvas(bar_frame, width = current_round_correct_bar_length, height = 15, highlightthickness=0, bg = "green4")
            current_round_bar_label = tk.Label(bar_frame, text=f"This round: {current_round_correct}/{current_round_total}", relief = "flat", font=({app_settings['font']}, app_settings['font_size']), bg = widgets_color_light, fg = "gray")
            """



            print(f"Bar coefficients: {total_bar_coefficient}, {current_round_bar_coefficient}")
            
            # ==== Progress bar widgets ====

            bar_frame_border.grid(row = 0, column = 0, rowspan = 3, columnspan = 3, sticky = "nw") #place(relx=0.0, rely=0.0, anchor = 'nw')
            bar_frame.pack()
            bar_frame.rowconfigure(2, minsize = 40)  # Gets 2/3 of extra space

            if app_settings["elimination_mode"] == True:
                total_total_bar_length = total_total * total_bar_coefficient # should always end up as 150
                total_correct_bar_length = total_correct * total_bar_coefficient
                #total_incorrect_bar_length = total_incorrect * total_bar_coefficient

            current_round_total_bar_length = current_round_total * current_round_bar_coefficient # should always end up as 150
            current_round_correct_bar_length = current_round_correct * current_round_bar_coefficient
            current_round_incorrect_bar_length = current_round_incorrect * current_round_bar_coefficient

            if app_settings["elimination_mode"] == True:
                total_total_bar.grid(row = 3, column = 0, sticky = "w")
                total_total_bar.config(width = total_total_bar_length)
                #if total_incorrect > 0:
                    #total_incorrect_bar.grid(row = 3, column = 0, sticky = "w")
                    #total_incorrect_bar.config(width = total_incorrect_bar_length, bg = "red3")
                #else:
                    #total_incorrect_bar.config(width = 0, bg = "lightgray") # hide widget if no incorrect answer
                if total_correct > 0:
                    total_correct_bar.grid(row = 3, column = 0, sticky = "w")
                    total_correct_bar.config(width = total_correct_bar_length, bg = "green4")
                else:
                    total_correct_bar.config(width = 0, bg = "lightgray") # hide widget if no correct answers
                total_bar_label.grid(row = 2, column = 0, sticky = "s")
                total_bar_label.config(text = f"total: {total_correct}/{total_total}")

            current_round_total_bar.grid(row = 1, column = 0, sticky = "w")
            current_round_total_bar.config(width = current_round_total_bar_length)
            if current_round_incorrect > 0:
                current_round_incorrect_bar.grid(row = 1, column = 0, sticky = "w")
                current_round_incorrect_bar.config(width = current_round_incorrect_bar_length, bg = "red3")
            else:
                current_round_incorrect_bar.config(width = 0, bg = "lightgray")
            if current_round_correct > 0:
                current_round_correct_bar.grid(row = 1, column = 0, sticky = "w")
                current_round_correct_bar.config(width = current_round_correct_bar_length, bg = "green4")
            else:
                current_round_correct_bar.config(width = 0, bg = "lightgray")
            current_round_bar_label.grid(row = 0, column = 0, sticky = "s")
            current_round_bar_label.config(text = f"Round {round_number}: {current_round_correct}/{current_round_total}")

            bar_frame_border_width = bar_frame_border.winfo_width()
            bar_frame_border_height = bar_frame_border.winfo_height()

            print(f"Bar frame border size: width = {bar_frame_border_width}, height = {bar_frame_border_height}")

    def start_timer(answer, timer_check):
        print("Start timer1")
        nonlocal timer_active
        recall_time = float(app_settings["timer_length"])
        typing_coefficient = float(app_settings["timer_length_coefficient"])
        typing_time = typing_coefficient * len(answer)
        total_time = recall_time + typing_time
        start_time = time.time()
        timer_active = True

        def update_timer(timer_check):
            nonlocal timer_start_time, timer_active
            if timer_check == timer_start_time:
                elapsed = time.time() - start_time
                
                if elapsed >= total_time:
                    # Timer finished - create red circle
                    img = Image.new('RGBA', (60, 60), (240, 235, 216, 0))  # Transparent background matching widgets_color_light
                    
                    #photo = ImageTk.PhotoImage(img)
                    timer_canvas.delete("all")
                    #timer_canvas.create_image(40, 40, image=photo)
                    #timer_canvas.image = photo  # Keep a reference so it doesn't get garbage collected
                    timer_active = False
                    print(f"Time is over: Timer active = {timer_active}")

                    if app_settings["timer_sound"] == True:
                        print("Attempt to play sound")
                        sound_path = os.path.join(DATA_DIR, "timer ended.wav")
                        sound = pygame.mixer.Sound(sound_path)
                        sound.set_volume(app_settings["timer_sound_volume"])  # Set volume to 50% (range is 0.0 to 1.0)
                        sound.play()

                    return
                
                # Calculate remaining degrees
                progress = elapsed / total_time
                remaining_degrees = 360 * (1 - progress)
                
                # Create smooth pie slice
                img = Image.new('RGBA', (60, 60), (240, 235, 216, 0))  # Transparent background
                draw = ImageDraw.Draw(img)
                
                # Draw the pie slice (start from top, going clockwise)
                draw.pieslice([5, 5, 30, 30], start=-90-remaining_degrees, end=-90, fill='green')
                
                img = img.filter(ImageFilter.GaussianBlur(radius=.6))

                # Convert to PhotoImage and display
                photo = ImageTk.PhotoImage(img)
                timer_canvas.delete("all")
                timer_canvas.create_image(30, 30, image=photo)
                timer_canvas.image = photo  # Important: keep reference!
                
                timer_canvas.after(50, lambda: update_timer(timer_check))
            else:
                timer_canvas.delete("all")
                return
        update_timer(timer_check)

    def handle_enter_key(event):
    # Check if Shift is held down
        shift_held = bool(event.state & 0x1)
    
        if shift_held:
            # Shift+Enter: allow line break
            return None  # Continue with normal text insertion
        else:
            # Regular Enter: submit answer
            check_answer()
            return "break"  # Prevent Enter from being inserted

    #response_box.bind("<Return>", handle_enter_key)

    def resize_widgets():
        nonlocal prompt_box
        frame_width = root.winfo_width()
        print(f"frame width: {frame_width}")
        wrap_width = int(frame_width) - 296
        if wrap_width > 200:
            prompt_box.config(wraplength = wrap_width)

        return "break"

    def clean_answer():
        nonlocal answer, response, answer_clean, response_clean
        show_answer_override = False
        if app_settings['must_match_capitalization'] == False: # remove caps according to settings
            answer1 = answer.lower()
            response1 = response.lower()
        else:
            answer1 = answer
            response1 = response

        if app_settings['must_match_punctuation'] == False: # remove punctuation according to settings
            answer2 = f""
            for char in answer1:
                if char not in string.punctuation or char == "-":
                    answer2 += char
            response2 = f""
            for chara in response1:
                if chara not in string.punctuation or chara == "-":
                    response2 += chara
        else:
            answer2 = answer1
            response2 = response1

        # ==== Create lists for diacritic analysis ====

        combining_diacritics = [
        (0x0300, 0x036F),  # Combining Diacritical Marks (Latin, Greek, Cyrillic)
        (0x0591, 0x05C7),  # Hebrew diacritics (nikud)
        (0x0610, 0x061A),  # Arabic diacritics
        (0x064B, 0x065F),  # Arabic vowel marks
        (0x0670, 0x0670),  # Arabic superscript alef
        (0x06D6, 0x06ED),  # Arabic small letters
        (0x0711, 0x0711),  # Syriac
        (0x0730, 0x074A),  # Syriac diacritics
        (0x07A6, 0x07B0),  # Thaana vowels
        (0x07EB, 0x07F3),  # NKo diacritics
        (0x0816, 0x0823),  # Samaritan diacritics
        (0x0825, 0x082D),  # Samaritan vowels
        (0x0951, 0x0954),  # Devanagari stress marks
        (0x0E47, 0x0E4E),  # Thai tone marks
        (0x0EC8, 0x0ECD),  # Lao tone marks
        (0x1DC0, 0x1DFF),  # Combining Diacritical Marks Supplement
        (0x20D0, 0x20FF),  # Combining Marks for Symbols
        (0xFE20, 0xFE2F),  # Combining Half Marks
        ]

        # Dictionary mapping precomposed characters to their base forms
        precomposed_diacritics = {
        # Latin with diacritics
        'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a', 'æ': 'ae',
        'ç': 'c',
        'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e',
        'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i',
        'ñ': 'n',
        'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o', 'ø': 'o', 'ơ' : 'o',
        'ù': 'u', 'ú': 'u', 'û': 'u', 'ü': 'u', 'ư' : 'u',
        'ý': 'y', 'ÿ': 'y',
        # Uppercase versions
        'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A', 'Æ': 'AE',
        'Ç': 'C',
        'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E',
        'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I',
        'Ñ': 'N',
        'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'O', 'Ø': 'O',
        'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'U',
        'Ý': 'Y',
        # Add more as needed - Vietnamese, Polish, Czech, etc.
        'ă': 'a', 'ắ': 'a', 'ằ': 'a', 'ẳ': 'a', 'ẵ': 'a', 'ặ': 'a',
        # You can keep adding to this dictionary
        }
        def remove_combining_diacritics(text):
            """Remove standalone combining diacritics using predefined ranges"""
            result = []
            for char in text:
                char_code = ord(char)
                # Check if character is in any diacritic range
                is_diacritic = False
                for start, end in combining_diacritics:
                    if start <= char_code <= end:
                        print(f"Diacritic removed: {char}")
                        is_diacritic = True
                        break
                
                if not is_diacritic:
                    result.append(char)
            
            return ''.join(result)

        def convert_precomposed_to_base(text):
            print("Reducing precomposed diacritics")
            """Convert precomposed characters to base forms using predefined dictionary"""
            result = []
            for char in text:
                # Use the dictionary if character is in it, otherwise keep original
                result.append(precomposed_diacritics.get(char, char))
            
            return ''.join(result)
        
        answer3 = convert_precomposed_to_base(answer2)
        response3 = convert_precomposed_to_base(response2)

        answer_clean = remove_combining_diacritics(answer3)
        response_clean = remove_combining_diacritics(response3)



        color_key_first_pass = []
        matcher_first_pass = SequenceMatcher(None, answer2, response2)
        accuracy = matcher_first_pass.ratio()
        if accuracy < 1:
            show_answer_override = True
        print(f"answer2: {answer2}")
        print(f"response2: {response2}")
        opcodes_first_pass = matcher_first_pass.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_first_pass:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 - j1):
                    color_key_first_pass.append(9) # 9 for an exact match (highest priority since this is the first pass)
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_first_pass.append(6) # incorrect (wrong character with high priority)
            elif op1 == "insert":
                for _ in range(k2 - k1):
                    color_key_first_pass.append(3) # incorrect (user typed an extra character)
            else:
                for _ in range(j2 - j1):
                    color_key_first_pass.append(0) # incorrect (user missed a character)

        print(f"Color key first pass: {color_key_first_pass}")

        if app_settings["must_match_diacritics"] == False:

            # ==== Get accuracy score ====

            matcher_grade = SequenceMatcher(None, answer_clean, response_clean) # fix the grade if must_match_diacritics is toggled off
            accuracy = matcher_grade.ratio()
            print(f"Accuracy re-adjusted: {accuracy}")

        # ==== begin non-diacritic-sensitive analysis of response. For users who can not type special characters on their device. ====
        # Color_key handles a widget that gives user feedback on their response. Ideal behavior:
            # all matching characters displayed as green
            # closest equivalent of a special character may be displayed as gray if it matches the corresponding special character in answer
            # incorrect characters displayed as red (including if user input a special character that doesn't match the answer)

        # ==== Check for composed diacritics (special characters that stand on their own, and don't hang above or below another character.)

        color_key_second_pass = [] # check if converted composed diacritics match answer
        matcher_second_pass = SequenceMatcher(None, answer3, response3)
        print(f"answer3: {answer3}")
        print(f"response3: {response3}")
        opcodes_second_pass = matcher_second_pass.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_second_pass:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 - j1):
                    color_key_second_pass.append(8) # match found (8 = user typed character that maps to the correct composed diacritic)
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_second_pass.append(6) # user typed the wrong character
            elif op1 == "insert":
                for _ in range(k2 - k1):
                    color_key_second_pass.append(3) # user typed an extra character
            else:
                for _ in range(j2 - j1):
                    color_key_second_pass.append(0) # user missed a character

        print(f"Color key second pass: {color_key_second_pass}")

        color_key_response_composed_diacritics = [] # unused code block. Tracks which characters in response were composed diacritics.
        matcher_response_composed_diacritics = SequenceMatcher(None, response3, response2)
        print(f"response3: {response3}")
        print(f"response2: {response2}")
        opcodes_response_composed_diacritics = matcher_response_composed_diacritics.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_response_composed_diacritics:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 - j1):
                    color_key_response_composed_diacritics.append(1) # Not converted
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_response_composed_diacritics.append(7) # converted character
            elif op1 == "insert":
                for _ in range(k2 - k1):
                    color_key_response_composed_diacritics.append(2) # combining diacritic detected
            else:
                for _ in range(j2 - j1):
                    color_key_response_composed_diacritics.append(3) # combining diacritic detected

        print(f"Composed diacritics detector: {color_key_response_composed_diacritics}")

        # ==== Look for combining diacritics in response ====

        color_key_response_combining_diacritics = []
        matcher_response_combining_diacritics = SequenceMatcher(None, response3, response_clean)
        print(f"response3: {response3}")
        print(f"response_clean: {response_clean}")
        opcodes_response_combining_diacritics = matcher_response_combining_diacritics.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_response_combining_diacritics:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 -j1):
                    color_key_response_combining_diacritics.append(0) # not a combining diacritic
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_response_combining_diacritics.append(0) # should never trigger
            elif op1 == "insert":
                for _ in range(k2 - k1):
                    color_key_response_combining_diacritics.append(0) # should never trigger
            else:
                for _ in range(j2 - j1):
                    color_key_response_combining_diacritics.append(7) # combining diacritic detected

            print(f"Diacritics in typed response: {color_key_response_combining_diacritics}")

        # ==== Search for places that user failed to write in a combining diacritic. This unusual search method is used to ensure the answer matches up with the other keys. ====

        color_key_answer_combining_diacritics_1 = [] # Look for combining diacritics in answer
        matcher_answer_combining_diacritics_1 = SequenceMatcher(None, answer3, response3)
        print(f"answer3: {answer3}")
        print(f"response3: {response3}")
        opcodes_answer_combining_diacritics_1 = matcher_answer_combining_diacritics_1.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_answer_combining_diacritics_1:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 - j1):
                    color_key_answer_combining_diacritics_1.append(1) # matching character
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_answer_combining_diacritics_1.append(2) # user typed wrong character
            elif op1 == "insert":
                for _ in range(k2 - k1):
                    color_key_answer_combining_diacritics_1.append(3) # user typed an extra character
            else:
                for _ in range(j2 - j1):
                    color_key_answer_combining_diacritics_1.append(4) # user missed a character

        print(f"Combined diacritics detector (answer): {color_key_answer_combining_diacritics_1}")

        color_key_answer_combining_diacritics_2 = [] # Look for combining diacritics in answer
        matcher_answer_combining_diacritics_2 = SequenceMatcher(None, answer_clean, response3)
        print(f"answer_clean: {answer_clean}")
        print(f"response3: {response3}")
        opcodes_answer_combining_diacritics_2 = matcher_answer_combining_diacritics_2.get_opcodes()
        for op1, j1, j2, k1, k2 in opcodes_answer_combining_diacritics_2:
            print(f"{op1}, {j1}, {j2}, {k1}, {k2}")

            if op1 == "equal":
                for _ in range(j2 -j1):
                    color_key_answer_combining_diacritics_2.append(1) # not a combining diacritic
            elif op1 == "replace":
                for _ in range(j2 - j1):
                    color_key_answer_combining_diacritics_2.append(2) # user typed wrong character
            elif op1 == "insert":
                for _ in range(k2 - j1):
                    color_key_answer_combining_diacritics_2.append(3) # combining diacritic detected
            else:
                for _ in range(j2 - j1):
                    color_key_answer_combining_diacritics_2.append(4) # diacritic found

        print(f"Second combined diacritics detector (answer): {color_key_answer_combining_diacritics_2}")

        # ==== compare the lists to find where the diacritics are supposed to be. (where the first list has an element that's absent from the second) ====
        
        while len(color_key_answer_combining_diacritics_1) > len(color_key_answer_combining_diacritics_2):
            color_key_answer_combining_diacritics_2.append(0) # First fix the second list so it's the same length as the first

        color_key_answer_combining_diacritics_3 = [] # this list will get passed to next code block
        while len(color_key_answer_combining_diacritics_1) > len(color_key_answer_combining_diacritics_3):
            color_key_answer_combining_diacritics_3.append(0) # fix the length of this list too

        for j, marker in enumerate(color_key_answer_combining_diacritics_1):
            if marker == 4:
                color_key_response_combining_diacritics.insert(j, 0)


        def xor_search():

            for i, marker in enumerate(color_key_answer_combining_diacritics_1): # search through the lists to find which parts they differ
                if marker == 2 or marker == 4:
                    marker2 = color_key_answer_combining_diacritics_2[i]
                    if marker2 == 0 or marker2 == 1 or marker2 == 3:
                        color_key_answer_combining_diacritics_3[i] = 10 # 5 for the places where a diacritic belongs in the answer
                        color_key_answer_combining_diacritics_2.insert(i, 4)
                        return xor_search() # at every part where the lists differ, repair the difference, record where difference was, and start again to find the next
            return
        xor_search()

        print(f"Combining diacritics 1: {color_key_answer_combining_diacritics_1}")
        print(f"Combining diacritics 2: {color_key_answer_combining_diacritics_2}")
        print(f"Combining diacritics in answer: {color_key_answer_combining_diacritics_3}")
        print(f"Repaired typed diacritics list: {color_key_response_combining_diacritics}")

        # ==== Put all the keys together to get final color_key ====

        combining_diacritics_key = [max(a, b) for a, b in zip_longest(color_key_answer_combining_diacritics_3, color_key_response_combining_diacritics, fillvalue=0)]
        print(f"Combined_diacritics_key: {combining_diacritics_key}") # 10 for where there's supposed to be a (combining) diacritic, 7 for where user typed a (combining) diacritic ()

        first_two_passes_key = [max(a, b) for a, b in zip_longest(color_key_first_pass, color_key_second_pass, fillvalue=0)]
        print(f"First combined list (puts composed diacritics into key): {first_two_passes_key}") # 9 for exact matches, 8 for when user wrote next closest thing, 6 = wrong character, 3 = extra character, 0 = missing character

        synthesis_key = [max(a, b) for a, b in zip_longest(first_two_passes_key, combining_diacritics_key, fillvalue=0)]
        print(f"Synthesis key): {synthesis_key}") # 9 = exact match (green), 8 = closest thing (gray), 3 = extra character (red), 6 = wrong (regular) character (red), 7 = user typed extra (or incorrect) combining diacritic (red and preceding character should turn red too), 10 = user missed a (combining) diacritic (gray and preceding character should turn gray iff it was green)

        color_key = []

        for j, marker in enumerate(synthesis_key):
            if marker == 9:
                print(f"key: {marker}: Do nothing")
                color_key.append(marker)
            elif marker == 8:
                if app_settings["must_match_diacritics"] == True:
                    print(f"key: {marker}: user should have typed a composed diacritic here")
                    color_key.append(6)
                else:
                    print(f"key: {marker}: user should have typed a composed diacric here, but settings set to forgive")
                    color_key.append(marker)
            elif marker == 6:
                print(f"key: {marker}: Do nothing")
                color_key.append(marker)
            elif marker == 3:
                print(f"key: {marker}: Do nothing")
                color_key.append(marker)
            elif marker == 0:
                print(f"key: {marker}: Do nothing")
                color_key.append(marker)
            elif marker == 7:
                print(f"key: {marker}: Wrong diacritic, change seat character to red")
                color_key[(j - 1)] = 6
                color_key.append(marker)
            elif marker == 10:
                print(f"key: {marker}: Missing diacritic")
                if app_settings["must_match_diacritics"] == False:
                    if synthesis_key[(j - 1)] == 9:
                        color_key[(j - 1)] = 8
                else:
                    color_key[(j - 1)] = 6
                color_key.append(marker)
            else:
                print(f"Unexpected error handling color key. Marker = {marker}")
                color_key.append(marker)

        pass_color_key = []
        for marker in color_key:
            if not marker == 10:
                if not marker == 0:
                    pass_color_key.append(marker)

        color_key = pass_color_key

        print(f"Response: {response}")
        print(f"Grading complete. Color key: {color_key}")

        return accuracy, color_key, show_answer_override
    def handle_correct_answer():
        nonlocal prompt, answer, response
        nonlocal timer_active
        print(f"Checking answer: timer = {timer_active}")
        globals()[f"round_{round_number}_correct"].append(active_item) # visual studio coloring is misleading, this line works properly.
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Correct"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue
        
        next_study_item()
    
        return "break"
    
    def handle_time_out(): # user submitted correct answer but timer ran out
        nonlocal prompt, answer, response
        globals()[f"round_{round_number}_incorrect"].append(active_item) # visual studio coloring is misleading, this line works properly.
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Correct: Timed out"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue
        
        next_study_item()
        return "break"
    
    def override_correct_answer():
        feedback_box.config(text="Override: Correct", fg = "yellow4")
        response_box.config(fg = "green")
        progress_bars(True, True) # temporary = true, temporary_answer_is_correct = True
        root.unbind("<Return>")
        root.bind("<Return>", lambda event: handle_override_correct_answer())

    def handle_override_correct_answer():
        nonlocal prompt, answer, response
        globals()[f"round_{round_number}_correct"].append(active_item) # visual studio coloring is misleading, this line works properly.
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Override: Correct"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue
        
        next_study_item()
    
        return "break"
    

    def handle_incorrect_answer():
        nonlocal prompt, answer, response
        print(f"in handle incorrect answer response: {response}")
        globals() [f"round_{round_number}_incorrect"].append(active_item) # visual studio coloring is misleading, this line works properly
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Incorrect"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue

        if mode == "write":
            if app_settings["retype_wrong_answer"] == True:
                retype_wrong_answer_setup()
            else:
                next_study_item()
        else:
            next_study_item()
        return "break"
    
    def handle_blank_answer(): # bug somewhwere when handling blank answers
        print("Blank answer detected")
        nonlocal answer, response, prompt, answer_clean, response_clean
        nonlocal timer_start_time
        #progress_bars()
        
        response_box.grid(row= 5 + app_settings["answer_box_size"], column = 1)
        you_said_box.grid(row= 4 + app_settings["answer_box_size"], column = 0, columnspan = 2)
        you_said_box.config(text = "Type answer")
        
        corrections_box_2.grid(row = 3, column = 0, columnspan = 2)
        corrections_box.grid(row = 4, column = 1, columnspan = 2)
        corrections_box.config(state = "normal")
        #response_box.place(relx=0.5, rely=0.4, y= 144, anchor = 'center') # move response box to make way for corrections_frame
        #response_box.delete("1.0", "end")

        #corrections_frame.place(relx=0.5, rely=0.5, anchor = 'center')
        print(f"mark 9, response = {response}")
        corrections_box.delete("1.0", "end")
        corrections_box.insert("1.0", answer)
        corrections_box_2.config(text="Correct answer:", fg = "red")
        print("mark 10")
        #response_box.insert("1.0", response)

        print ("mark 12")
        
        print(f"in handle incorrect answer response: {response}")
        globals()[f"round_{round_number}_incorrect"].append(active_item) # visual studio coloring is misleading, this line works properly
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Blank"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue

        print("Mark 16: Retype wrong answer")
        root.unbind(f"<Key-{app_settings['override_correct']}>")
        root.unbind(f"<Key-{app_settings['override_incorrect']}>")
        #response_box.bind("<Return", retype_wrong_answer())
        feedback_box.config(text="Type answer", fg = widgets_color_text)
        response_box.config(state="normal")
        response_box.delete("1.0", "end")

        timer_start_time = None # This variable deletes the timer when set to None
        
        retype_wrong_answer_setup()
        
        return

    def override_incorrect_answer():
        feedback_box.config(text="Override: Incorrect", fg = "yellow4")
        response_box.config(fg = "red")
        progress_bars(True, False) # temporary = true, temporary_answer_is_correct = False
        root.unbind("<Return>")
        root.bind("<Return>", lambda event: handle_override_incorrect_answer())

    def handle_override_incorrect_answer():
        nonlocal prompt, answer_clean, response_clean, answer, response
        globals()[f"round_{round_number}_incorrect"].append(active_item) # visual studio coloring is misleading, this line works properly.
        globals()[f"round_{round_number}_study_progress"].append((prompt, answer, response, "Override: Incorrect"))
        if globals().get(f"round_{round_number}_must_study", []):
            del globals()[f"round_{round_number}_must_study"][0] # remove correct answer from queue
        
        next_study_item()
    
        return "break"

    def check_answer(): # Check answer (or in reveal mode, reveal answer)
        nonlocal answer, response, answer_clean, response_clean
        nonlocal matcher
        nonlocal active_item
        nonlocal override_correct_button, override_incorrect_button, i_knew_this_button, i_did_not_know_this_button, show_answer_button
        nonlocal timer_start_time, timer_active
        global tooltip_tracker, tooltip_holder
        tooltip_tracker = False
        try:
            tooltip_holder.destroy()
            tooltip_holder = None
        except:
            tooltip_holder = None
        print ("Mark 8 - Check answer")
        timer_start_time = None # this variable deletes the timer when set to None
        
        response = response_box.get("1.0", "end-1c")

        accuracy, color_key, show_answer_override = clean_answer() # removes, caps, diacritics, and punctuation according to settings
        print(f"Accuracy: {accuracy}")

        if mode == "write":
            root.bind(f"<Key-{app_settings['override_correct']}>", lambda event: override_correct_answer())
            #override_correct_button = tk.Button(content_frame, text = f"Override: Correct ({app_settings['override_correct']})", width = 25, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: override_correct_answer())
            #override_correct_button.grid(row = 6, column = 1, columnspan = 4, padx = 40, sticky = "nw", pady = 10) #place(x = 350, y = 425)
            #override_correct_button.bind("<Enter>", lambda event, tooltip_send = f"Override: I was correct": on_hover(event, "light", tooltip_send))
            #override_correct_button.bind("<Leave>", lambda event: on_default(event, "light"))

            #response_box.bind(f"<{app_settings['override_correct']}>", lambda event: next_study_item())
            #response_box.bind(f"<{app_settings['override_correct']}>", lambda event: progress_bars())
            root.bind(f"<Key-{app_settings['override_incorrect']}>", lambda event: override_incorrect_answer())
            #override_incorrect_button = tk.Button(content_frame, text = f"Override: Incorrect ({app_settings['override_incorrect']})", width = 25, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: override_incorrect_answer())
            #override_incorrect_button.grid(row = 6, column = 5, columnspan = 3, padx = 40, sticky = "nw", pady = 10) #place(x = 100, y = 425)
            #override_incorrect_button.bind("<Enter>", lambda event, tooltip_send = f"Override: I was incorrect": on_hover(event, "light", tooltip_send))
            #override_incorrect_button.bind("<Leave>", lambda event: on_default(event, "light"))

            response_box.unbind("<Return>")
            if not response:
                print("Blank")
                handle_blank_answer()
                return "break"

            print(f"answer: {answer_clean}")
            print(f"response: {response_clean}")
            print(len(globals()[f"round_{round_number}_must_study"]))

            print(f"response: {response_clean}")    

            root.unbind("<Return")
            
            if f"{app_settings['allow_typos']}" == f"True":
                accuracy_threshold = f"{app_settings["typo_leniency"]}"
            else:
                accuracy_threshold = 0.99

            print(f"override correct: {app_settings['override_correct']}")
            print(f"override incorrect: {app_settings['override_incorrect']}")
            
            #response_box.bind("<Key-t>", lambda event: next_study_item())
            #response_box.bind("<Key-t>", lambda event: progress_bars())
            
            # override button for incorrect
            print(f"response: {response_clean}")
            timed_out = False
            if app_settings["timer"] == True:
                if timer_active == False: # user timed out
                    timed_out = True

            if accuracy == 1:
                if timed_out == True:
                    print("Mark 13: Correct answer (but user timed out)")
                    response_box.configure(state="disabled", fg = "green")
                    feedback_box.configure(text="Correct! (but timed out)", fg = "yellow4")
                    progress_bars(True, False) # temporary = true, temporary_answer_is_correct = False
                    corrections(0, color_key, show_answer_override, timed_out) # Pass variable "0" to tell corrections function it was 100% correct
                    if app_settings["quick_submit_answer"] == True:
                        handle_time_out()
                    else:
                        root.bind("<Return>", lambda event: handle_time_out())
                else:
                    print("mark 13: Correct answer")
                    response_box.configure(state="disabled", fg = "green")
                    feedback_box.configure(text="Correct!", fg = "green")
                    progress_bars(True, True) # temporary = true, temporary_answer_is_correct = True
                    corrections(0, color_key, show_answer_override) # Pass variable "0" to tell corrections function it was 100% correct
                    if app_settings["quick_submit_answer"] == True:
                        handle_correct_answer()
                    else:
                        root.bind("<Return>", lambda event: handle_correct_answer())
                    #response_box.bind("<Return>", lambda event: next_study_item())

            elif accuracy >= float(accuracy_threshold):
                if timed_out == True:
                    print("mark 13: Correct answer (mostly) (but user timed out)")
                    feedback_box.configure(text=f"Correct! (mostly) (but timed out)", fg = "yellow4")
                    progress_bars(True, False) # temporary = true, temporary_answer_is_correct = False
                    corrections(1, color_key, show_answer_override, timed_out) # Pass variable "1" to tell corrections function it was off but close enough
                    if app_settings["quick_submit_answer"] == True:
                        handle_time_out()
                    else:
                        root.bind("<Return>", lambda event: handle_time_out())
                    #response_box.bind("<Return>", lambda event: next_study_item())
                else:
                    print("mark 13: Correct answer (mostly)")
                    feedback_box.configure(text="Correct! (mostly)", fg = "green")
                    progress_bars(True, True) # temporary = true, temporary_answer_is_correct = True
                    corrections(1, color_key, show_answer_override) # Pass variable "0" to tell corrections function it was 100% correct
                    if app_settings["quick_submit_answer"] == True:
                        handle_correct_answer()
                    else:
                        root.bind("<Return>", lambda event: handle_correct_answer())

            else:
                print("mark 13: Incorrect")
                feedback_box.configure(text="Incorrect!", fg = "red")
                corrections(2, color_key) # pass variable "2" to tell corrections function it was incorrect
                progress_bars(True, False) # temporary = true, temporary_answer_is_correct = False
                print("Mark 15.5: Call function retype_wrong_answer")
                #response_box.bind("<Return>", lambda event: handle_incorrect_answer())
                if app_settings["quick_submit_answer"] == True:
                    handle_incorrect_answer()
                else:
                    root.bind("<Return>", lambda event: handle_incorrect_answer())

            #progress_bars()

            return "break"
        
        elif mode == "reveal":
            response_box.config(state="normal")
            response_box.insert("1.0", answer)
            response_box.config(state="disabled")
            root.unbind("<Return>")
            root.unbind("<space>")
            root.bind(f"<Key-{app_settings['override_correct']}>", lambda event: handle_correct_answer())
            root.bind(f"<Key-{app_settings['override_incorrect']}>", lambda event: handle_incorrect_answer())

            if show_answer_button:
                show_answer_button.destroy()
                show_answer_button = None

            i_knew_this_button = tk.Button(content_frame, text = f"I knew this term ({app_settings['override_correct']})", width = 25, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: handle_correct_answer())
            i_knew_this_button.grid(row = 9, column = 1, columnspan = 4, padx = 40, pady = 10, sticky = "w") #place(x = 50, y = 425)
            i_knew_this_button.bind("<Enter>", lambda event, tooltip_send = f"Press {app_settings['override_correct']} or click this button to mark this term as 'learned'.": on_hover(event, "light", tooltip_send))
            i_knew_this_button.bind("<Leave>", lambda event: on_default(event, "light"))

            i_did_not_know_this_button = tk.Button(content_frame, text = f"I didn't know this term ({app_settings['override_incorrect']})", width = 25, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "gray", height = 1, relief = "raised", command = lambda: handle_incorrect_answer())
            i_did_not_know_this_button.grid(row = 9, column = 5, columnspan = 3, padx = 40, pady = 10, sticky = "e") #place(x = 350, y = 425)
            i_did_not_know_this_button.bind("<Enter>", lambda event, tooltip_send = f"Press {app_settings['override_incorrect']} or click this button to mark this term as 'not yet learned'.": on_hover(event, "light", tooltip_send))
            i_did_not_know_this_button.bind("<Leave>", lambda event: on_default(event, "light"))

    def fade_fast_feedback_widgets(score, color_key, start_time_check, timed_out = False):
        print("fast feedback time step")
        nonlocal fast_feedback_box, fast_corrections_box, correct_answer_box, fast_you_said_box, you_said_you_said_box, fast_feedback_frame, fade_fast_feedback_widgets_start_time


        if start_time_check == fade_fast_feedback_widgets_start_time:# Cancel any existing timer
            elapsed = time.time() - fade_fast_feedback_widgets_start_time
            duration = 6
            fade_amount = (elapsed / duration)

                # Convert hex to RGB
            gray_r, gray_g, gray_b = int("#808080"[1:3], 16), int("#808080"[3:5], 16), int("#808080"[5:7], 16)
            dark_blue_r, dark_blue_g, dark_blue_b = int(navigation_color_backgrounds[1:3], 16), int(navigation_color_backgrounds[3:5], 16), int(navigation_color_backgrounds[5:7], 16)
            green_r, green_g, green_b = int("#008000"[1:3], 16), int("#008000"[3:5], 16), int("#008000"[5:7], 16)        
            red_r, red_g, red_b = int("#FF0000"[1:3], 16), int("#FF0000"[3:5], 16), int("#FF0000"[5:7], 16)
            background_r, background_g, background_b = int(widgets_color_medium[1:3], 16), int(widgets_color_medium[3:5], 16), int(widgets_color_medium[5:7], 16)
            yellow_r, yellow_g, yellow_b = int("#8B8B00"[1:3], 16), int("#8B8B00"[3:5], 16), int("#8B8B00"[5:7], 16)
            
            # Interpolate
            new_gray_r = int(gray_r + (background_r - gray_r) * fade_amount)
            new_gray_g = int(gray_g + (background_g - gray_g) * fade_amount)
            new_gray_b = int(gray_b + (background_b - gray_b) * fade_amount)

            new_gray = f"#{new_gray_r:02x}{new_gray_g:02x}{new_gray_b:02x}"

            new_dark_blue_r = int(dark_blue_r + (background_r - dark_blue_r) * fade_amount)
            new_dark_blue_g = int(dark_blue_g + (background_g - dark_blue_g) * fade_amount)
            new_dark_blue_b = int(dark_blue_b + (background_b - dark_blue_b) * fade_amount)

            new_dark_blue = f"#{new_dark_blue_r:02x}{new_dark_blue_g:02x}{new_dark_blue_b:02x}"

            new_green_r = int(green_r + (background_r - green_r) * fade_amount)
            new_green_g = int(green_g + (background_g - green_g) * fade_amount)
            new_green_b = int(green_b + (background_b - green_b) * fade_amount)

            new_green = f"#{new_green_r:02x}{new_green_g:02x}{new_green_b:02x}"

            new_red_r = int(red_r + (background_r - red_r) * fade_amount)
            new_red_g = int(red_g + (background_g - red_g) * fade_amount)
            new_red_b = int(red_b + (background_b - red_b) * fade_amount)

            new_red = f"#{new_red_r:02x}{new_red_g:02x}{new_red_b:02x}"

            new_yellow_r = int(yellow_r + (background_r - yellow_r) * fade_amount)
            new_yellow_g = int(yellow_g + (background_g - yellow_g) * fade_amount)
            new_yellow_b = int(yellow_b + (background_b - yellow_b) * fade_amount)

            new_yellow = f"#{new_yellow_r:02x}{new_yellow_g:02x}{new_yellow_b:02x}"

            print(f"In fade fast feedback widgets, score = {score}, timed_out = {timed_out}")

            if score == 0:
                if timed_out == True:
                    fast_feedback_box.config(fg = new_yellow)
                else:
                    fast_feedback_box.config(fg = new_green)
            elif score == 1:
                if timed_out == True:
                    fast_feedback_box.config(fg = new_yellow)
                else:
                    fast_feedback_box.config(fg = new_green)       
            else:    
                fast_feedback_box.config(fg = new_red)

            fast_you_said_box.config(state = "normal")
            fast_you_said_box.tag_config("correct", foreground=new_green)
            fast_you_said_box.tag_config("incorrect", foreground=new_red)
            fast_you_said_box.tag_config("unmarked", foreground = "gray")
            # 9 = (green), 8 = (gray), 3 = (red), 6 =(red), 7 = (red), 5 = (gray)

            for i, key in enumerate(color_key):
                position_start = f"1.{i}"
                position_end = f"1.{i + 1}"
                if key == 9:
                    fast_you_said_box.tag_add("correct", position_start, position_end)
                elif key == 8:
                    fast_you_said_box.tag_add("unmarked", position_start, position_end)
                else:
                    fast_you_said_box.tag_add("incorrect", position_start, position_end)
            
            fast_you_said_box.config(state="disabled")
            fast_corrections_box.config(fg = new_dark_blue)
            you_said_you_said_box.config(fg = new_gray)
            correct_answer_box.config(fg = new_gray)

            #EBDDD1 (background color)
            #808080	RGB(128,128,128) (gray)
            #2c3e50
            #008000	RGB(0,128,0) (green)
            #FF0000	RGB(255,0,0) (red (possibly?))

            if elapsed >= duration:
                fast_feedback_box.destroy()
                fast_corrections_box.destroy()
                correct_answer_box.destroy()
                fast_you_said_box.destroy()
                you_said_you_said_box.destroy()
                fast_feedback_frame.destroy()
                print ("Time is up")
                return "break"

            root.after(25, lambda: fade_fast_feedback_widgets(score, color_key, start_time_check, timed_out))         
        else:
            return

    def corrections(score, color_key, show_answer_override = False, timed_out = False):
        nonlocal answer, response, answer_clean, response_clean
        nonlocal matcher
        nonlocal fast_feedback_frame, fast_feedback_box, correct_answer_box, fast_corrections_box, you_said_you_said_box, fast_you_said_box, fade_fast_feedback_widgets_start_time
        #progress_bars()
        if fast_feedback_box:
            fast_feedback_box.destroy()
        if fast_corrections_box:
            fast_corrections_box.destroy()
        if correct_answer_box:
            correct_answer_box.destroy()
        if fast_you_said_box:
            fast_you_said_box.destroy()
        if you_said_you_said_box:
            you_said_you_said_box.destroy()
        if fast_feedback_box:
            fast_feedback_frame.destroy()
            
        if app_settings["quick_submit_answer"] == True:
            print("Fast mode active")
            fast_feedback_frame = tk.Frame(content_frame, bg = widgets_color_medium, width = 500, height = 300) #EBDDD1
            fast_feedback_frame.grid(row = 10, column = 2, columnspan = 6, sticky = "w") #place(x = 20, y = 380)
            fast_feedback_box = tk.Label(fast_feedback_frame, text = "tt", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text)
            fast_feedback_box.grid(row = 0, column = 0, columnspan = 2, padx = (100, 5), sticky = "w")

            correct_answer_box = tk.Label(fast_feedback_frame, text = "Correct answer: ", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = "gray")
            correct_answer_box.grid(row = 1, column = 0, sticky = "e")
            fast_corrections_box = tk.Label(fast_feedback_frame, text = "vv", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text)
            fast_corrections_box.grid(row = 1, column = 1, sticky = "w")
            you_said_you_said_box = tk.Label(fast_feedback_frame, text = "You said: ", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = "gray")
            you_said_you_said_box.grid(row = 2, column = 0, sticky = "e")
            fast_you_said_box = tk.Text(fast_feedback_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, relief = "flat", fg = widgets_color_text, height = 1, width = 70)
            fast_you_said_box.grid(row = 2, column = 1, sticky = "w")
            print("Generated all widgets")

            if score == 0: # perfect match
                if timed_out == True:
                    fast_feedback_box.config(text = "100% Correct (but timed out)", fg = "yellow4")
                else:
                    fast_feedback_box.config(text = "100% Correct", fg = "green")

            elif score == 1: # slightly off but within tolerance
                if timed_out == True:
                        fast_feedback_box.config(text = "Correct (mostly) (but timed out)", fg = "yellow4")
                else:
                    fast_feedback_box.config(text = "Correct (mostly)", fg = "yellow4")      
            
            else: # incorrect answer
                fast_feedback_box.config(text = "Incorrect", fg = "red")
                        
            fast_corrections_box.config(text = answer)
            fast_you_said_box.insert("1.0", response)
        
            fast_you_said_box.tag_config("correct", foreground="green")
            fast_you_said_box.tag_config("incorrect", foreground="red")
            fast_you_said_box.tag_config("unmarked", foreground = "gray")

            # 9 = (green), 8 = (gray), 3 = (red), 6 =(red), 7 = (red)
            print("mark 11")


            # ==== this function breaks when coloring languages that use rtl combining characters. If response uses these characters, just skip the recoloring part ====
            if not any('\u0600' <= ch <= '\u06FF' for ch in response):
                
                # Recolor letters in the user's response to give readable feedback
                for i, key in enumerate(color_key):
                    position_start = f"1.{i}"
                    position_end = f"1.{i + 1}"
                    if key == 9:
                        fast_you_said_box.tag_add("correct", position_start, position_end)
                    elif key == 8:
                        fast_you_said_box.tag_add("unmarked", position_start, position_end)
                    else:
                        fast_you_said_box.tag_add("incorrect", position_start, position_end)
            
            fast_you_said_box.config(state="disabled")

            print ("mark 12")

            fade_fast_feedback_widgets_start_time = time.time()
            fade_fast_feedback_widgets(score, color_key, fade_fast_feedback_widgets_start_time, timed_out)
            if score == 0:
                next_study_item()
            elif score == 1:
                next_study_item()
            else:
                retype_wrong_answer_setup()
             
        if not score == 0 or show_answer_override: # if response wasn't a perfect match
            response_box.grid(row= 5 + app_settings["answer_box_size"], column = 1)
            you_said_box.grid(row= 4 + app_settings["answer_box_size"], column = 0, columnspan = 2)
            you_said_box.config(text = "You said:")
            corrections_box_2.grid(row = 3, column = 0, columnspan = 2)
            corrections_box.grid(row = 4, column = 1, columnspan = 2)
            corrections_box.config(state = "normal")
            #response_box.place(relx=0.5, rely=0.4, y= 144, anchor = 'center') # move response box to make way for corrections_frame
            #response_box.delete("1.0", "end")

            #corrections_frame.place(relx=0.5, rely=0.5, anchor = 'center')
            print(f"mark 9, response = {response}")
            
            corrections_box.delete("1.0", "end")
            corrections_box.insert("1.0", answer)
            corrections_box_2.config(text="Correct answer:", fg = "gray")
            print("mark 10")
            #response_box.insert("1.0", response_clean)

            response_box.tag_config("correct", foreground="green")
            response_box.tag_config("incorrect", foreground="red")
            response_box.tag_config("unmarked", foreground = "gray")
            # 9 = (green), 8 = (gray), 3 = (red), 6 =(red), 7 = (red)
            print("mark 11")

            # ==== this function breaks when coloring languages that use rtl combining characters. If response uses these characters, just skip the recoloring part ====
            if any('\u0600' <= ch <= '\u06FF' for ch in response):
                if score == 0:
                    response_box.config(fg = "green")  
                if score == 1:
                    response_box.config(fg = "yellow4")      
                if score == 2:
                    response_box.config(fg = "red3")
            else:
                for i, key in enumerate(color_key):
                    position_start = f"1.{i}"
                    position_end = f"1.{i + 1}"
                    if key == 9:
                        response_box.tag_add("correct", position_start, position_end)
                    elif key == 8:
                        response_box.tag_add("unmarked", position_start, position_end)
                    else:
                        response_box.tag_add("incorrect", position_start, position_end)

            response_box.config(state="disabled")

            print ("mark 12")

        return "break"

    def retype_wrong_answer_setup():
        nonlocal answer, response, answer_clean, response_clean
        nonlocal override_correct_button, override_incorrect_button
        nonlocal timer_start_time

        #response_box.unbind("<Return")
        print("Mark 16: Retype wrong answer")
        root.unbind(f"<Key-{app_settings["override_correct"]}>")
        root.unbind(f"<Key-{app_settings["override_incorrect"]}>")

        if override_correct_button:
            override_correct_button.destroy()
            override_correct_button = None
        if override_incorrect_button:
            override_incorrect_button.destroy()
            override_incorrect_button = None
        
        #root.unbind("<Key-t>")
        #root.unbind("<Key-y>")
        #response_box.bind("<Return", retype_wrong_answer())
        if not response: # blank answer submitted
            feedback_box.config(text = "Blank response, please type the answer")
            you_said_box.config(text = "Type the answer")
        else:
            feedback_box.config(text="Incorrect, retype answer", fg = widgets_color_text)
            you_said_box.config(text = "Retype answer")
        response_box.config(state="normal")
        response_box.delete("1.0", "end")

        timer_start_time = None # this variable deletes the timer when set to None
        response_box.unbind("<Return>")
        root.unbind("<Return>")
        #if app_settings["quick_submit_answer"] == True:
        #    retype_wrong_answer()
        #else:
            
        response_box.bind("<Return>", lambda event: retype_wrong_answer())       
        return "break"

    def retype_wrong_answer():
        nonlocal override_correct_button, override_incorrect_button
        nonlocal answer, response, answer_clean, response_clean
        nonlocal matcher
        nonlocal timer_start_time

        root.unbind("<Return>")
        response_box.unbind("<Return>")

        response_box.config(state="disabled")
        you_said_box.config(text = "")
        response = response_box.get("1.0", "end-1c")

        if not response: # blank answer submitted
            feedback_box.config(text = "Blank response, please type the answer")
            you_said_box.config(text = "Type the answer")
            retype_wrong_answer_setup()
            return "break"
            
        accuracy, color_key, show_answer_override = clean_answer() # removes, caps, diacritics, and punctuation according to settings

        print(f"retype_answer: {answer_clean}")
        print(f"retype_response: {response_clean}")
        print(len(globals()[f"round_{round_number}_must_study"]))

        print(f"accuracy: {accuracy}")

        root.unbind("<Return>")
        response_box.unbind("<Return>")

        if accuracy == 1:
            feedback_box.config(text="Good job", fg = "green")
            response_box.config(fg = "green")
            corrections(0, color_key, show_answer_override)
            #corrections_box.delete("1.0", "end")
    
            #corrections_box.insert("1.0", "Yay! Good job!")
            print("Yay! Good job!")
            if app_settings["quick_submit_answer"] == True:
                lambda event: next_study_item()
            else:
                response_box.config(state = "disabled")
                response_box.bind("<Return>", lambda event: next_study_item())

        else:
            corrections(2, color_key)
            feedback_box.config(text="Try again", fg = "red")
            #corrections_box.delete("1.0", "end")
            #corrections_box.insert("1.0", "Try again")
            print("Try again")
            if app_settings["quick_submit_answer"] == True:
                retype_wrong_answer_setup()
            else:
                response_box.config(state = "disabled")
                response_box.bind("<Return>", lambda event: retype_wrong_answer_setup())
        
        print("Mark 17: End of retype_wrong_answer")

        return "break"    

    next_round()
    next_study_item()
    resize_widgets()

    # Create a tag with red color
    response_box.tag_config("typo_indicator", foreground="red") # typo indicator functionality incomplete

    # Add scrollbar
    scrollbar = tk.Scrollbar(content_frame, orient="vertical", command=settings_text.yview)
    settings_text.configure(yscrollcommand=scrollbar.set)
    
    # Pack scrollbar and text widget
    scrollbar.pack(side="right", fill="y")
    settings_text.pack(side="left", fill="both", expand=True)
    
    # Enable text widget temporarily to insert content
    settings_text.config(state="normal")
    return # fill this in later

def midi_clicked():
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    clear_content()
    label = tk.Label(content_frame, text="MIDI Cards mode - for sight reading practice!\nComing soon!", 
                    font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
    label.pack(pady=50)

def stats_clicked(view_amount = 15, show_all = False):
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    clear_content()
    #content_frame.pack(fill="both", expand=True, padx=10, pady=10)
    check_for_name_errors(FLASHCARDS_DIR)

    """
    end_of_session_frame = tk.Frame(main_area, bg = widgets_color_light)
    end_of_session_frame.pack(side="left", fill="both", expand = True)
    content_frame.pack_forget()

    end_of_session_canvas = tk.Canvas(end_of_session_frame, bg = widgets_color_medium)
    end_of_session_canvas.pack(side = "left", fill="both", expand = True)
    statistics_frame = tk.Frame(end_of_session_canvas, bg = widgets_color_light)
    statistics_frame.pack(fill = "both", expand = True)
    statistics_frame.columnconfigure(0, weight = 1)
    #canvas_window = end_of_session_canvas.create_window((0, 0), window = statistics_frame, anchor = "nw")
    """
    content_frame.config(bg = widgets_color_medium, padx = 10, pady = 10)
    main_canvas = tk.Canvas(content_frame, bg = widgets_color_medium)
    main_canvas.pack(fill=tk.BOTH, expand=True)
    scrollable_frame = tk.Frame(main_canvas, bg = widgets_color_medium, padx = 15, pady = 15)
    scrollable_frame.pack(fill = "both", expand = True)
    scrollable_frame.columnconfigure(0, weight = 1)

    stats_scrollbar = tk.Scrollbar(main_canvas, orient="vertical", command=main_canvas.yview)
    stats_scrollbar_horizontal = tk.Scrollbar(main_canvas, orient="horizontal", command=main_canvas.xview)
    main_canvas.configure(yscrollcommand=stats_scrollbar.set)
    main_canvas.configure(xscrollcommand=stats_scrollbar_horizontal.set)
    

    canvas_window = main_canvas.create_window((0,0), window = scrollable_frame, anchor = "ne")

    # Create canvas and scrollbar
    """
    canvas = tk.Canvas(main_frame, bg = widgets_color_medium)
    scrollbar = tk.Scrollbar(main_frame, orient=tk.VERTICAL, command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg = "blue")
    """

    # Configure canvas scrolling
    main_canvas.configure(yscrollcommand=stats_scrollbar.set)
    main_canvas.bind('<Configure>', lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all")))

    # configure horizontal scrolling

    horizontal_scrolling = False

    def horizontal_scrolling_toggle_on(event):
        nonlocal horizontal_scrolling
        horizontal_scrolling = True
        print("Horizontal scrolling ON")

    def horizontal_scrolling_toggle_off(event):
        nonlocal horizontal_scrolling
        horizontal_scrolling = False
        print("Horizontal scrolling OFF")

    # Bind the keys (do this once, outside the function)
    root.bind("<KeyPress-Shift_L>", horizontal_scrolling_toggle_on)
    root.bind("<KeyRelease-Shift_L>", horizontal_scrolling_toggle_off)
    root.bind("<KeyPress-Control_L>", horizontal_scrolling_toggle_on)
    root.bind("<KeyRelease-Control_L>", horizontal_scrolling_toggle_off)



    if system == "Windows" or system =="Darwin":
        def on_mousewheel(event):
            nonlocal horizontal_scrolling
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            main_canvas_height = main_canvas.winfo_height()

            scrollable_frame_width = scrollable_frame.winfo_width()
            main_canvas_width = main_canvas.winfo_width()

            print(f"Scrollable frame height: {scrollable_frame_height}, Main canvas height: {main_canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            print("attempt to scroll")
            if horizontal_scrolling == True:
                if scrollable_frame_width > main_canvas_width:
                    print("Horizontal scrolling")
                    main_canvas.xview_scroll(int(-1 * (event.delta / 120)), "units")
            else:
                if scrollable_frame_height > main_canvas_height:
                    main_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

        root.bind("<MouseWheel>", on_mousewheel)  # Windows/Mac
    else:
        print("setup scroll for Linux")
        def on_mousewheel_linux_down(event):
            nonlocal horizontal_scrolling
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            main_canvas_height = main_canvas.winfo_height()

            scrollable_frame_width = scrollable_frame.winfo_width()
            main_canvas_width = main_canvas.winfo_width()

            print(f"Scrollable frame height: {scrollable_frame_height}, Main canvas height: {main_canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            print("attempt to scroll")
            if horizontal_scrolling == True:
                if scrollable_frame_width > main_canvas_width:
                    print("Horizontal scrolling")
                    main_canvas.xview_scroll(int(-1 * (event.delta / 120)), "units")
            else:
                if scrollable_frame_height > main_canvas_height:
                    main_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

        def on_mousewheel_linux_up(event):
            nonlocal horizontal_scrolling
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            main_canvas_height = main_canvas.winfo_height()

            scrollable_frame_width = scrollable_frame.winfo_width()
            main_canvas_width = main_canvas.winfo_width()

            print(f"Scrollable frame height: {scrollable_frame_height}, Main canvas height: {main_canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====

            print("attempt to scroll")
            if horizontal_scrolling == True:
                if scrollable_frame_width > main_canvas_width:
                    print("Horizontal scrolling")
                    main_canvas.xview_scroll(int(1 * (event.delta / 120)), "units")
            else:
                if scrollable_frame_height > main_canvas_height:
                    main_canvas.yview_scroll(int(1 * (event.delta / 120)), "units")
                else:
                    print("Could not scroll")

        root.bind("<Button-4>", on_mousewheel_linux_up)  # Linux
        root.bind("<Button-5>", on_mousewheel_linux_down)  # Linux

    # Create window inside canvas
    #canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

    # Pack scrollbar and canvas
    stats_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    stats_scrollbar_horizontal.pack(side=tk.BOTTOM, fill=tk.X)
    #main_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    must_search_folders = []
    folders_list = []
    flashcards_list = []
    headers = []
    flashcard_widgets = {}

    must_search_folders.append((FLASHCARDS_DIR, "Your decks"))
    folders_list.append((FLASHCARDS_DIR, "Your decks"))

    print(f"must search folders: {must_search_folders}")

    def search_folders():
        nonlocal must_search_folders, folders_list, flashcards_list
        folder_detected = []
        print(f"Before loop, must search folders: {must_search_folders}")
        for parent_folder, name in must_search_folders:
            print(f"In loop, must search folders: {must_search_folders}")
            items = []
            items += os.listdir(parent_folder)
            for item in items:
                full_path = os.path.join(parent_folder, item)
                
                if os.path.isdir(full_path):
                    folder_detected.append((full_path, item))
                    folders_list.append((full_path, item))
        print(f"folders detected: {folder_detected}")
        print(f"Items: {items}")
        must_search_folders = folder_detected
        print(f"end of loop, must search folders: {must_search_folders}")
    
    def search_flashcards():
        print("Search Flashcards")
        nonlocal must_search_folders, folders_list, flashcards_list
        for i, tuple in enumerate(folders_list):
            folder = tuple[0]
            folder_name = tuple[1]
            flashcards_list_handling = []
            print(f"flashcards handling: {flashcards_list_handling}")
            items = []
            print(f"All items: {items}")
            items += os.listdir(folder)
            for item in items:
                if item.lower().endswith(('.txt', '.midi', '.pdf')):
                    flashcards_list_handling.append(item)

            for j, handling in enumerate(flashcards_list_handling):
                print(f"Mark A - {handling}")
                match = re.search(r'(-?\d+)[_ -](.+)', handling)
                if match:
                    name_clean = match.group(2)
                    name_clean = os.path.splitext(name_clean)[0]  # Remove extension
                else:
                    name_clean = os.path.splitext(handling)[0] # if no match found (unlikely) just display file name

                print(f"Mark T: deck name = {name_clean}")
                
                flashcards_list.append((i, j, folder, folder_name, handling, name_clean))

            #for j, item2 in enumerate(flashcards_list_handling):
            #    flashcards_list.append((i, j, folder, folder_name, item2))
                    
        print(f"flashcard list: {flashcards_list}")
        print(f"folder list: {folders_list}")

    while must_search_folders != []:
        search_folders()

    search_flashcards()
    print(f"Flash cards list: {flashcards_list}")
    scrollable_frame.columnconfigure(0, minsize = 20)
    scrollable_frame.columnconfigure(1, minsize = 230)
    
    for p, tuple in enumerate(flashcards_list): # populate left hand column
        folder_number = tuple[0]
        item_number = tuple[1]
        folder_path = tuple[2]
        folder_name = tuple[3]
        flashcard_set = tuple[4]
        flashcard_set_name_clean = tuple[5]

        background = tk.Canvas(scrollable_frame, bg = widgets_color_light, height = 1, width = 1)
        background.grid(row = (p + folder_number + 2), column = 1, sticky = "nsew", pady = (0,2), padx = (0,2))

        if item_number == 0:
            match = re.search(r'(-?\d+)[_ -](.+)', folder_name)
            if match:
                folder_name_clean = match.group(2)
                folder_name_clean = os.path.splitext(folder_name_clean)[0]  # Remove extension
            else:
                folder_name_clean = os.path.splitext(folder_name)[0] # if no match found (unlikely) just display file name

            print(f"Mark V: folder name = {folder_name_clean}")

            header = tk.Label(scrollable_frame, text = folder_name_clean, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, wraplength = 280) # name of folder
            header.grid(row = (p + folder_number + 1), column = 0, columnspan = 2, sticky = "w", pady = (0, 2), padx = (0,2))

        full_path = os.path.join(folder_path, flashcard_set)
        button_command = lambda path=full_path: flashcard_set_overview(path, True)

        print(f"Attempt to populate stats area: {folder_number}, {tuple}")
        item_label = tk.Label(scrollable_frame, text = f"{flashcard_set_name_clean}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text, wraplength = 220) # button widgets don't handle long strings of text well so this widget helps set the size of the grid, then stays in the background
        item_label.grid(row = (p + folder_number + 2), column = 1, sticky = "w", pady = (0, 2), padx = (0,2))
        #item_height = item_label.winfo_height()
        #print(f"Item height: {item_height}")
        #item_label.gridforget()
        #button_color_palette = "light"

        flashcard_widgets[f"{flashcard_set_name_clean}_label"] = tk.Button(
            scrollable_frame,
            text = f"{flashcard_set_name_clean}",
            width=22, 
            height=1,
            wraplength = 220, 
            font=(app_settings['font'], app_settings['font_size']),
            anchor="w",
            justify="left",
            relief="flat",
            bd=0,
            command=button_command,
            bg = widgets_color_light, 
            fg = "#696969")
        flashcard_widgets[f"{flashcard_set_name_clean}_label"].grid(row = (p + folder_number + 2), column = 1, sticky = "nsew", pady = (0, 2), padx = (0,2))

        flashcard_widgets[f"{flashcard_set_name_clean}_label"].bind('<Leave>', lambda event: on_default(event, "light"))
        flashcard_widgets[f"{flashcard_set_name_clean}_label"].bind('<Enter>', lambda event: on_hover(event, "light", "Study this deck"))
        
    # ==== Retrieve statistics ====
    """
    try:
        if os.path.exists(STATS_FILE):
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                statistics = json.load(f)
                # Convert lists back to tuples if needed
                statistics = [tuple(item) for item in statistics]
            
            print(f"Statistics: {statistics}")
    except Exception as e:
        print(f"Error: {e}")
        statistics = []
    
    """
    statistics = []

    try:
        if os.path.exists(STATS_FILE):
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                
                for line in lines:
                    line = line.strip()
                    if line:
                        match
                        statistics.append(eval(line))
            
            print(f"Statistics: {statistics}")
    except Exception as e:
        print(f"Error: {e}")
        statistics = []

    if statistics == []:
        print("Error, could not find statistics")
        clear_content()
        error_box = tk.Label(content_frame, text = "You don't have any saved statistics yet :(", font=({app_settings['font']}, app_settings['font_size']), 
                                                    bg = widgets_color_light, fg = widgets_color_text)
        error_box.place(relx = 0.5, rely = 0.2, anchor = "center")
        return
    def remove_duplicates():
        nonlocal statistics
        statistics.sort()
        updated_statistics = []
        statistics_compare = statistics
        last_date = None
        last_deck_name = None

        for tuple in statistics:
            date_str = tuple[0]
            deck_name = tuple[1]
            grade = tuple[2]
            print("Next item in Statistics")
            print(f"Date: {date_str}")
            print(f":Grade: {grade}")
            print(f"Deck name: {deck_name}")

            if date_str == last_date and deck_name == last_deck_name:
                print("duplicate found")
            else:
                updated_statistics.append(tuple)
            
            last_date = date_str
            last_deck_name = deck_name
        statistics = updated_statistics
        print("Statistics successfully updated")
        print(f"Statistics: {statistics}")

    remove_duplicates()

    # ==== Update Statistics folder ====
    try:
        with open(STATS_FILE, 'w', encoding='utf-8') as f:
            for line in statistics:
                f.write(f"{line}\n")
    except Exception as e:
        print(f"Error saving settings: {e}")

    # ==== Display Statistics in scrollable_frame ====

    day_counter = 0
    month_counter = 0 # controls the size of the label at the top which displays the month
    month_labels = {}
    year_tracker = None
    month_tracker = None
    date_tracker = None
    for tuple in reversed(statistics): # Iterate in reverse order so that most recent items are processed first.
        if day_counter < view_amount:
            date_str = tuple[0]
            deck_name = tuple[1]
            grade = tuple[2]

            if date_str != date_tracker:
                print(f"Setting up date: {date_str}")
                date_tracker = date_str
                day_counter = day_counter + 1

                match = re.match(r"(\d{4}), (\d{2}), (\d{2})", date_str)
                if match:
                    year = match.group(1)
                    month = match.group(2)
                    day = match.group(3)
                    print(f"Successfully separated date numbers: Year: {year}, Month: {month}, Day: {day}")

                    # ==== Change the month number to the English word ====
                    months_english = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                    month_index = (int(month) - 1)
                    month = months_english[month_index] 
                    print(f"Translated month to English word: {month}")
                else:
                    print("Date could not be read")
                    year = year_tracker
                    month = month_tracker # month_tracker should be "None" or month from previous item. If for some reason there's no match, the item will fall back to this.
                    day = (view_amount - day_counter + 1)
                
                if month == month_tracker and year == year_tracker:
                    month_counter = (month_counter + 1)
                else:
                    month_counter = 0
                    month_tracker = month
                    year_tracker = year

                print(f"Placement variables: Day counter: {day_counter}, Month counter: {month_counter}")
                print(f"Month label column = {(day_counter - month_counter + 1)}")
                label_key = f"{month}_{year}_label"

                if label_key not in month_labels:
                    # Create the label only if it doesn't exist yet
                    month_labels[label_key] = tk.Label(scrollable_frame, text=f"{month} {year}", 
                                                    font=({app_settings['font']}, app_settings['font_size']), 
                                                    bg = widgets_color_light, fg = "orange")

                # Always update the grid placement (whether new or existing label)
                month_labels[label_key].grid(row=0, column=(view_amount - day_counter + 2), 
                                        columnspan=(month_counter + 1), sticky="nswe", padx = (0, 2), pady = (2, 2))

                day_label = tk.Label(scrollable_frame, text = f"{day}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "orange", wraplength = 50)
                day_label.grid(row = 1, column = (view_amount - day_counter + 2), sticky = "we", pady = (0, 2), padx = (0,2))

                for p, deck_tuple in enumerate(flashcards_list):
                    folder_number = deck_tuple[0]
                    item_number = deck_tuple[1]
                    folder_path = deck_tuple[2]
                    folder_name = deck_tuple[3]
                    flashcard_set = deck_tuple[4]
                    flashcard_set_name_clean = deck_tuple[5]
                    
                    blank_entry = tk.Frame(scrollable_frame, bg = widgets_color_light, width = 1, height = 1)
                    blank_entry.grid(row = (p + folder_number + 2), column = (view_amount - day_counter + 2), sticky = "nsew", pady = (0, 2), padx = (0,2))

            for p, deck_tuple in enumerate(flashcards_list):
                folder_number = deck_tuple[0]
                item_number = deck_tuple[1]
                folder_path = deck_tuple[2]
                folder_name = deck_tuple[3]
                flashcard_set = deck_tuple[4]
                flashcard_set_name_clean = deck_tuple[5]

                #print(f" deck name: {deck_name}, flashcard set: {flashcard_set_name_clean}")
                if f"{deck_name}" == f"{flashcard_set_name_clean}":
                    print("Match found, attempt to populate statistics grid")

                    if flashcard_widgets[f"{flashcard_set_name_clean}_label"]:
                        # ==== gray out items over time if they haven't been reviewed in a long time ====

                        today = date.today()
                        print(f"Today: {today}")
                        today_str = str(today)
                        print(f"Date: {date_str}")

                        #today_year = int(today_str[1:3])
                        #today_month = int(today_str[3:5])
                        #today_day = int(today_str[5:7])

                        today_match = re.match(r"(\d{4})-(\d{2})-(\d{2})", today_str)
                        if today_match:
                            today_year = today_match.group(1)
                            today_month = today_match.group(2)
                            today_day = today_match.group(3)

                        date_match = re.match(r"(\d{4}), (\d{2}), (\d{2})", date_str)
                        if date_match:
                            date_year = date_match.group(1)
                            date_month = date_match.group(2)
                            date_day = date_match.group(3)

                        year_diff = int(today_year) - int(date_year)
                        print(f"Year difference: {today_year} - {date_year} = {year_diff}")
                        month_diff = int(today_month) - int(date_month)
                        print(f"Month difference: {today_month} - {date_month} = {month_diff}")
                        day_diff = int(today_day) - int(date_day)
                        print(f"Year difference: {today_day} - {date_day} = {day_diff}")

                        year_diff_adjusted = year_diff * 365
                        month_diff_adjusted = month_diff * 30
                        day_diff_adjusted = day_diff * 1

                        days_since_last_studied = year_diff_adjusted + month_diff_adjusted + day_diff_adjusted

                        print(f"Days since last studied: {days_since_last_studied}")

                        # ==== calculate faded out colors based on days since last studied ====
                        if days_since_last_studied < 120:
                            fade_amount =  days_since_last_studied / 120

                            #gray_r, gray_g, gray_b = int("#808080"[1:3], 16), int("#808080"[3:5], 16), int("#808080"[5:7], 16)
                            dark_blue_r, dark_blue_g, dark_blue_b = int("#696969"[1:3], 16), int("#696969"[3:5], 16), int("#696969"[5:7], 16)
                            green_r, green_g, green_b = int("#008000"[1:3], 16), int("#008000"[3:5], 16), int("#008000"[5:7], 16)        
                            red_r, red_g, red_b = int("#FF0000"[1:3], 16), int("#FF0000"[3:5], 16), int("#FF0000"[5:7], 16)
                            background_r, background_g, background_b = int("#696969"[1:3], 16), int("#696969"[3:5], 16), int("#696969"[5:7], 16)
                            yellow_r, yellow_g, yellow_b = int("#8B8B00"[1:3], 16), int("#8B8B00"[3:5], 16), int("#8B8B00"[5:7], 16)
                            
                            # Interpolate
                            #new_gray_r = int(gray_r + (background_r - gray_r) * fade_amount)
                            #new_gray_g = int(gray_g + (background_g - gray_g) * fade_amount)
                            #new_gray_b = int(gray_b + (background_b - gray_b) * fade_amount)

                            #new_gray = f"#{new_gray_r:02x}{new_gray_g:02x}{new_gray_b:02x}"

                            new_dark_blue_r = int(dark_blue_r + (background_r - dark_blue_r) * fade_amount)
                            new_dark_blue_g = int(dark_blue_g + (background_g - dark_blue_g) * fade_amount)
                            new_dark_blue_b = int(dark_blue_b + (background_b - dark_blue_b) * fade_amount)

                            new_dark_blue = f"#{new_dark_blue_r:02x}{new_dark_blue_g:02x}{new_dark_blue_b:02x}"

                            new_green_r = int(green_r + (background_r - green_r) * fade_amount)
                            new_green_g = int(green_g + (background_g - green_g) * fade_amount)
                            new_green_b = int(green_b + (background_b - green_b) * fade_amount)

                            new_green = f"#{new_green_r:02x}{new_green_g:02x}{new_green_b:02x}"

                            new_red_r = int(red_r + (background_r - red_r) * fade_amount)
                            new_red_g = int(red_g + (background_g - red_g) * fade_amount)
                            new_red_b = int(red_b + (background_b - red_b) * fade_amount)

                            new_red = f"#{new_red_r:02x}{new_red_g:02x}{new_red_b:02x}"

                            new_yellow_r = int(yellow_r + (background_r - yellow_r) * fade_amount)
                            new_yellow_g = int(yellow_g + (background_g - yellow_g) * fade_amount)
                            new_yellow_b = int(yellow_b + (background_b - yellow_b) * fade_amount)

                            new_yellow = f"#{new_yellow_r:02x}{new_yellow_g:02x}{new_yellow_b:02x}"

                            if grade < 3: 
                                deck_color_code = new_green
                            elif grade < 5:
                                deck_color_code = new_yellow
                            elif grade > 4:
                                deck_color_code = new_red
                            else:
                                deck_color_code = new_dark_blue

                            flashcard_widgets[f"{flashcard_set_name_clean}_label"].config(fg = deck_color_code)
                            flashcard_widgets[f"{flashcard_set_name_clean}_label"] = None # removes reference to widget so that the most recent score won't be overwritten by later, older scores

                        else:
                            deck_color_code = navigation_color_backgrounds
                            flashcard_widgets[f"{flashcard_set_name_clean}_label"].config(fg = deck_color_code)
                            flashcard_widgets[f"{flashcard_set_name_clean}_label"] = None # removes reference to widget so that the most recent score won't be overwritten by later, older scores

                    color_code = "808080"

                    if grade < 3: 
                        color_code = "#008000"
                    elif grade < 5:
                        color_code = "#8B8B00"
                    elif grade > 4:
                        color_code = "#FF0000"

                    entry = tk.Label(scrollable_frame, text = f"{grade}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = color_code, wraplength = 220)
                    entry.grid(row = (p + folder_number + 2), column = (view_amount - day_counter + 2), sticky = "nsew", pady = (0, 2), padx = (0,2))

                    entry.bind("<Enter>", lambda event, tooltip_send = f"On {month} {day}, {year}, you completed this deck in {grade} rounds.": on_hover(event, "light", tooltip_send))
                    entry.bind("<Leave>", lambda event: on_default(event, "light"))

    show_all_button = tk.Button(scrollable_frame, text = f"Show all", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = "#696969", height = 1, relief = "flat", bd = 0, command = lambda view_amount = 999, show_all = True: stats_clicked(view_amount, show_all))
    show_all_button.grid(row = 0, column = 1, sticky = "nse", pady = 2, padx = (0,2))
    show_all_button.bind("<Enter>", lambda event, tooltip = "Show all statistics", theme = "light": on_hover(event, theme, tooltip))
    show_all_button.bind("<Leave>", lambda event: on_default(event, "light"))

    if show_all == True:
        show_all_button.config(text = "Show less", command = lambda view_amount = 15, show_all = False: stats_clicked(view_amount, show_all))

def settings_clicked():
    global tooltip_tracker, tooltip_holder
    tooltip_tracker = False
    try:
        tooltip_holder.destroy()
        tooltip_holder = None
    except:
        tooltip_holder = None
    """Display current settings in a readable format"""
    clear_content()
    input_box = None
    
    main_frame = tk.Frame(content_frame)
    main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    main_frame.configure(bg = widgets_color_light)

    # Create canvas and scrollbar
    canvas = tk.Canvas(main_frame, bg = widgets_color_light)
    scrollbar = tk.Scrollbar(main_frame, orient=tk.VERTICAL, command=canvas.yview)
    scrollable_frame = tk.Frame(canvas, bg = widgets_color_light)

    # Configure canvas scrolling
    canvas.configure(yscrollcommand=scrollbar.set)
    canvas.bind('<Configure>', lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

    if system == "Windows" or system =="Darwin":
        def on_mousewheel(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, Canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if scrollable_frame_height > canvas_height:
                print("attempt to scroll")
                canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
            else:
                print("Could not scroll")

        root.bind("<MouseWheel>", on_mousewheel)  # Windows/Mac
    else:
        print("setup scroll for Linux")
        def on_mousewheel_linux_down(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, Canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if scrollable_frame_height > canvas_height:
                print("attempt to scroll")
                canvas.yview_scroll(-1, "units")
            else:
                print("Could not scroll")

        def on_mousewheel_linux_up(event):
            # ==== Start with a check to see if the scrollable frame is larger than the window ====
            scrollable_frame_height = scrollable_frame.winfo_height()
            canvas_height = canvas.winfo_height()

            print(f"Scrollable frame height: {scrollable_frame_height}, Canvas height: {canvas_height}")

            # ==== disable scrolling if frame is smaller than the window (this causes issues otherwise) ====
            if scrollable_frame_height > canvas_height:
                print("attempt to scroll")
                canvas.yview_scroll(1, "units")
            else:
                print("Could not scroll")

        root.bind("<Button-4>", on_mousewheel_linux_up)  # Linux
        root.bind("<Button-5>", on_mousewheel_linux_down)  # Linux

    # Create window inside canvas
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

    # Pack scrollbar and canvas
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    settings_display = f"""  Reverse term and definition: {app_settings['reverse_term_and_definition']}
  Quick submit: {app_settings['quick_submit_answer']}
  Retype wrong answer: {app_settings['retype_wrong_answer']}
  Elimination mode: {app_settings['elimination_mode']}
  Random order: {app_settings['random_order']}
  Show progress bars: {app_settings['show_progress_bars']}

  Timer enabled: {app_settings['timer']}
  Timer length: {app_settings['timer_length']} seconds
  Timer coefficient: {app_settings['timer_length_coefficient']}
  Timer sound: {app_settings['timer_sound']}

  Must match capitalization: {app_settings['must_match_capitalization']}
  Must match punctuation: {app_settings['must_match_punctuation']}
  Must match diacritics: {app_settings['must_match_diacritics']}
  Allow typos: {app_settings['allow_typos']}
  Typo leniency: {app_settings['typo_leniency']}
  Answer box size: {app_settings["answer_box_size"]}

  Font: {app_settings['font']}
  Font size: {app_settings['font_size']}
  Night mode: {app_settings['night_mode']}

  Override correct: {app_settings['override_correct']}
  Override incorrect: {app_settings['override_incorrect']}

  Collect stats: {app_settings['collect_stats']}

    """

    # ==== Settings buttons ====

    ####_button = tk.Button(scrollable_frame, text = f"####: {app_settings[f"####"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 50, relief = "flat", command = lambda reference = "####": update_settings_boolean(reference))
    ####_button.grid(row = 0, column = 0, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    ####_button.bind("<Enter>", lambda event, tooltip_send = "####": on_hover(event, "medium", tooltip_send))
    ####_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    reverse_term_and_definition_button = tk.Button(scrollable_frame, text = f"Reverse prompt and answer: {app_settings[f"reverse_term_and_definition"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "reverse_term_and_definition": update_settings_boolean(reference))
    reverse_term_and_definition_button.grid(row = 0, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    reverse_term_and_definition_button.bind("<Enter>", lambda event, tooltip_send = "Reverses term and definition": on_hover(event, "medium", tooltip_send))
    reverse_term_and_definition_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    quick_submit_answer_button = tk.Button(scrollable_frame, text = f"Quick submit answer: {app_settings[f"quick_submit_answer"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "quick_submit_answer": update_settings_boolean(reference))
    quick_submit_answer_button.grid(row = 0, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    quick_submit_answer_button.bind("<Enter>", lambda event, tooltip_send = "Answers submitted faster but give less feedback": on_hover(event, "medium", tooltip_send))
    quick_submit_answer_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    retype_wrong_answer_button = tk.Button(scrollable_frame, text = f"Retype wrong answers: {app_settings[f"retype_wrong_answer"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "retype_wrong_answer": update_settings_boolean(reference))
    retype_wrong_answer_button.grid(row = 1, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    retype_wrong_answer_button.bind("<Enter>", lambda event, tooltip_send = "Retype wrong answers": on_hover(event, "medium", tooltip_send))
    retype_wrong_answer_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    elimination_mode_button = tk.Button(scrollable_frame, text = f"Elimination mode: {app_settings[f"elimination_mode"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "elimination_mode": update_settings_boolean(reference))
    elimination_mode_button.grid(row = 1, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    elimination_mode_button.bind("<Enter>", lambda event, tooltip_send = "Correctly answered cards won't be showed again": on_hover(event, "medium", tooltip_send))
    elimination_mode_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    random_order_button = tk.Button(scrollable_frame, text = f"Randomize order: {app_settings[f"random_order"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "random_order": update_settings_boolean(reference))
    random_order_button.grid(row = 2, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    random_order_button.bind("<Enter>", lambda event, tooltip_send = "Decks get shuffled in a random order": on_hover(event, "medium", tooltip_send))
    random_order_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    show_progress_bars_button = tk.Button(scrollable_frame, text = f"Show progress bars: {app_settings[f"show_progress_bars"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "show_progress_bars": update_settings_boolean(reference))
    show_progress_bars_button.grid(row = 2, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    show_progress_bars_button.bind("<Enter>", lambda event, tooltip_send = "Progress bars are shown": on_hover(event, "medium", tooltip_send))
    show_progress_bars_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    override_correct_button = tk.Button(scrollable_frame, text = f"Override correct hotkey: {app_settings[f"override_correct"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "override_correct", row_number = 3, column_number = 1: update_settings_hotkey(reference, row_number, column_number))
    override_correct_button.grid(row = 3, column = 1, padx = (0, 2), pady = (0, 25), sticky = "we")
    override_correct_button.bind("<Enter>", lambda event, tooltip_send = "Change hotkey for Override: Correct": on_hover(event, "medium", tooltip_send))
    override_correct_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    override_incorrect_button = tk.Button(scrollable_frame, text = f"Override incorrect hotkey: {app_settings[f"override_incorrect"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "override_incorrect", row_number = 3, column_number = 0: update_settings_hotkey(reference, row_number, column_number))
    override_incorrect_button.grid(row = 3, column = 0, padx = (0, 2), pady = (0, 25), sticky = "we")
    override_incorrect_button.bind("<Enter>", lambda event, tooltip_send = "Change hotkey for Override: Incorrect": on_hover(event, "medium", tooltip_send))
    override_incorrect_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    timer_button = tk.Button(scrollable_frame, text = f"Enable timer: {app_settings[f"timer"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 76, relief = "flat", command = lambda reference = "timer": update_settings_boolean(reference))
    timer_button.grid(row = 4, column = 0, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    timer_button.bind("<Enter>", lambda event, tooltip_send = "Answers must be submitted within a time limit": on_hover(event, "medium", tooltip_send))
    timer_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    #timer_length_label = tk.Label(scrollable_frame, text = f"timer_length: ", font=(app_settings['font'], app_settings['font_size']), justify = "right", bg = widgets_color_medium, fg = widgets_color_text, width = 15, relief = "flat")
    #timer_length_label.grid(row = 7, column = 0, sticky = "e")
    #timer_length_float = tk.Text(scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 15, height = 1, relief = "flat")
    #timer_length_float.grid(row = 7, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    #timer_length_float.insert("1.0", app_settings[f"timer_length"])
    #timer_length_float.bind("<Enter>", lambda event, tooltip_send = "timer_length": on_hover(event, "medium", tooltip_send))
    #timer_length_float.bind("<Leave>", lambda event: on_default(event, "medium"))
    #timer_length_float.bind("<Return>", lambda event, reference = "timer_length": update_settings_float(event, reference))

    timer_length_button = tk.Button(scrollable_frame, text = f"Timer length: {app_settings[f"timer_length"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "timer_length", row_number = 5, column_number = 0: update_settings_float(reference, row_number, column_number))
    timer_length_button.grid(row = 5, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    timer_length_button.bind("<Enter>", lambda event, tooltip_send = f"Timer lasts at least {app_settings[f"timer_length"]} seconds": on_hover(event, "medium", tooltip_send))
    timer_length_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    timer_length_coefficient_button = tk.Button(scrollable_frame, text = f"Timer extension: {app_settings[f"timer_length_coefficient"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, height = 1, relief = "flat", command = lambda reference = "timer_length_coefficient", row_number = 5, column_number = 1: update_settings_float(reference, row_number, column_number))
    timer_length_coefficient_button.grid(row = 5, column = 1, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    timer_length_coefficient_button.bind("<Enter>", lambda event, tooltip_send2 = f"""Extends the timer by {app_settings[f"timer_length_coefficient"]} seconds for every letter in answer \n (so you have enough time to type out the answer)""": on_hover(event, "medium", tooltip_send2))
    timer_length_coefficient_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    timer_sound_button = tk.Button(scrollable_frame, text = f"Timer sound: {app_settings[f"timer_sound"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "timer_sound": update_settings_boolean(reference))
    timer_sound_button.grid(row = 6, column = 0, padx = (2, 2), pady = (0, 25), sticky = "we")
    timer_sound_button.bind("<Enter>", lambda event, tooltip_send10 = "Timer plays a sound": on_hover(event, "medium", tooltip_send10))
    timer_sound_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    timer_sound_volume_button = tk.Button(scrollable_frame, text = f"Timer sound volume: {app_settings[f"timer_sound_volume"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "timer_sound_volume", row_number = 6, column_number = 1, column_span = 1, max_value = 1: update_settings_float(reference, row_number, column_number, column_span, max_value))
    timer_sound_volume_button.grid(row = 6, column = 1, padx = (2, 2), pady = (0, 25), sticky = "we")
    timer_sound_volume_button.bind("<Enter>", lambda event, tooltip_send10 = "Range: 0-1": on_hover(event, "medium", tooltip_send10))
    timer_sound_volume_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    allow_typos_button = tk.Button(scrollable_frame, text = f"Allow typos: {app_settings[f"allow_typos"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "allow_typos": update_settings_boolean(reference))
    allow_typos_button.grid(row = 7, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    allow_typos_button.bind("<Enter>", lambda event, tooltip_send = "Allow slight typos": on_hover(event, "medium", tooltip_send))
    allow_typos_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    typo_leniency_button = tk.Button(scrollable_frame, text = f"Typo leniency: {app_settings[f"typo_leniency"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "typo_leniency", row_number = 7, column_number = 1, column_span = 1, max_value = 1: update_settings_float(reference, row_number, column_number, column_span, max_value))
    typo_leniency_button.grid(row = 7, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    typo_leniency_button.bind("<Enter>", lambda event, tooltip_send15 = f"Accuracy must be above {app_settings[f"typo_leniency"]}": on_hover(event, "medium", tooltip_send15))
    typo_leniency_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    must_match_capitalization_button = tk.Button(scrollable_frame, text = f"Must match capitalization: {app_settings[f"must_match_capitalization"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "must_match_capitalization": update_settings_boolean(reference))
    must_match_capitalization_button.grid(row = 8, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    must_match_capitalization_button.bind("<Enter>", lambda event, tooltip_send11 = "User's submitted responses must match capitalization": on_hover(event, "medium", tooltip_send11))
    must_match_capitalization_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    must_match_punctuation_button = tk.Button(scrollable_frame, text = f"Must match punctuation: {app_settings[f"must_match_punctuation"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "must_match_punctuation": update_settings_boolean(reference))
    must_match_punctuation_button.grid(row = 8, column = 1, padx = (0, 2), pady = (0, 2), sticky = "we")
    must_match_punctuation_button.bind("<Enter>", lambda event, tooltip_send12 = "User's submitted responses must match punctuation": on_hover(event, "medium", tooltip_send12))
    must_match_punctuation_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    must_match_diacritics_button = tk.Button(scrollable_frame, text = f"Must match diacritics: {app_settings[f"must_match_diacritics"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "must_match_diacritics": update_settings_boolean(reference))
    must_match_diacritics_button.grid(row = 9, column = 0, padx = (0, 2), pady = (0, 25), sticky = "we")
    must_match_diacritics_button.bind("<Enter>", lambda event, tooltip_send = "User's submitted responses must match diacritics (accent marks)": on_hover(event, "medium", tooltip_send))
    must_match_diacritics_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    answer_box_size_button = tk.Button(scrollable_frame, text = f"Answer box size: {app_settings[f"answer_box_size"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "answer_box_size", row_number = 10, column_number = 0, column_span = 2: update_settings_integer(reference, row_number, column_number, column_span))
    answer_box_size_button.grid(row = 10, column = 0, columnspan = 2, padx = (2, 2), pady = (0, 2), sticky = "we")
    answer_box_size_button.bind("<Enter>", lambda event, tooltip_send15 = f"Answer box size": on_hover(event, "medium", tooltip_send15))
    answer_box_size_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    font_button = tk.Button(scrollable_frame, text = f"Font: {app_settings[f"font"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "font", row_number = 11, column_number = 0: update_settings_string(reference, row_number, column_number))
    font_button.grid(row = 11, column = 0, padx = (0, 2), pady = (0, 2), sticky = "we")
    font_button.bind("<Enter>", lambda event, tooltip_send = "font": on_hover(event, "medium", tooltip_send))
    font_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    font_size_button = tk.Button(scrollable_frame, text = f"Font size: {app_settings[f"font_size"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "font_size", row_number = 11, column_number = 1: update_settings_integer(reference, row_number, column_number))
    font_size_button.grid(row = 11, column = 1, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    font_size_button.bind("<Enter>", lambda event, tooltip_send = "font size": on_hover(event, "medium", tooltip_send))
    font_size_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    # ==== Night mode works but I couldn't get it to look good (tkinter's scrollbars can't be configured, their color clashed too much) ====

    #night_mode_button = tk.Button(scrollable_frame, text = f"Night mode: {app_settings[f"night_mode"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 38, relief = "flat", command = lambda reference = "night_mode": update_settings_boolean(reference))
    #night_mode_button.grid(row = 12, column = 0, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    #night_mode_button.bind("<Enter>", lambda event, tooltip_send = "Night mode": on_hover(event, "medium", tooltip_send))
    #night_mode_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    collect_stats_button = tk.Button(scrollable_frame, text = f"Collect stats: {app_settings[f"collect_stats"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 50, relief = "flat", command = lambda reference = "collect_stats": update_settings_boolean(reference))
    collect_stats_button.grid(row = 13, column = 0, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    collect_stats_button.bind("<Enter>", lambda event, tooltip_send = "Collect stats": on_hover(event, "medium", tooltip_send))
    collect_stats_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    # ==== default study mode button functional but I decided I don't want it ====

    #default_study_mode_button = tk.Button(scrollable_frame, text = f"Default study mode: {app_settings[f"default_study_mode"]}", font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 50, relief = "flat", command = lambda reference = "default_study_mode", row_number = 14, column_number = 0, column_span = 2: update_settings_string(reference, row_number, column_number, column_span))
    #default_study_mode_button.grid(row = 14, column = 0, columnspan = 2, padx = (0, 2), pady = (0, 2), sticky = "we")
    #default_study_mode_button.bind("<Enter>", lambda event, tooltip_send = f""" Options: "none", "reveal", "write" """: on_hover(event, "medium", tooltip_send))
    #default_study_mode_button.bind("<Leave>", lambda event: on_default(event, "medium"))

    def update_settings_boolean(reference):
        print(f"Update settings boolean called. Reference = {reference} ({app_settings[f"{reference}"]})")
        if app_settings[f"{reference}"] == True:
            app_settings[f"{reference}"] = False
        else:
            app_settings[f"{reference}"] = True
        print(f"End of update_settings_boolean. Setting changed to {app_settings[f"{reference}"]}.")
        if reference == "night_mode":
            update_color_palette()
            global navigation_color_buttons, navigation_color_buttons_hover, navigation_color_backgrounds, navigation_color_text, widgets_color_light, widgets_color_medium, widgets_color_medium_dark, widgets_color_dark, widgets_color_text
            sidebar.config(bg = navigation_color_backgrounds)
            main_area.config(bg = widgets_color_light)
            content_frame.config(bg = widgets_color_light)

        save_settings(app_settings)
        settings_clicked()
    
    def update_settings_integer(reference, row_number, column_number, column_span = 1):
        nonlocal input_box
        print(f"Update settings integer called. Reference = {reference} ({app_settings[f"{reference}"]})")
        if input_box:
            input_box.destroy()
            input_box = None

        def submit_change():
            print("Saving change")
            new_value = input_box.get("1.0", "end-1c")
            new_value = abs(int(new_value))
            if new_value > 26:
                new_value = 26 # Avoid overly large numbers
            try:
                app_settings[f"{reference}"] = new_value
            except:
                print("Error: Must input an integer")
                input_box.delete("1.0", "end-1c")
                input_box.insert("1.0", "Error. Must input a number")
                return "break"
            print(f"Changed {reference} to {app_settings[f"{reference}"]}")
            save_settings(app_settings)
            input_box.destroy()
            settings_clicked()
            return "break"

        def cancel():
            print(f"Cancel: Don't update {reference}")
            input_box.destroy()
            settings_clicked()
            return "break"
        
        input_box = tk.Text(scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 15, height = 2, relief = "sunken")
        input_box.grid(row = row_number, column = column_number, columnspan = column_span, sticky = "nwe", padx = (0, 2), pady = (0, 0))
        input_box.focus_set()

        input_box.bind("<Return>", lambda event: submit_change())
        input_box.bind("<Escape>", lambda event: cancel())
        
    #def update_settings_float(event, reference):
    #    print(f"Update settings float called. Reference = {reference} ({app_settings[f"{reference}"]})")
    #    new_value = event.widget.get("1.0", "end-1c")
    #    app_settings[f"{reference}"] = new_value
    #    print(f"Changed {reference} to {app_settings[f"{reference}"]}")
    #    save_settings(app_settings)
    #    event.widget.master.focus_set()
    #    return "break"
    #def update_settings_hotkey(reference):

    def update_settings_float(reference, row_number, column_number, column_span = 1, max_value = 99):
        nonlocal input_box
        print(f"Update settings float (2) called. Reference = {reference} ({app_settings[f"{reference}"]})")
        #clear_content()
        #settings_clicked()
        if input_box:
            input_box.destroy()
            input_box = None

        def submit_change(max_value):
            print("Saving change")
            new_value = input_box.get("1.0", "end-1c")
            if float(new_value) > float(max_value):
                new_value = max_value
            try:
                app_settings[f"{reference}"] = abs(float(new_value))
            except:
                print("Error: Must input a number")
                input_box.delete("1.0", "end-1c")
                input_box.insert("1.0", "Error. Must input a number")
                return "break"
            print(f"Changed {reference} to {app_settings[f"{reference}"]}")
            save_settings(app_settings)
            input_box.destroy()
            settings_clicked()
            return "break"

        def cancel():
            print(f"Cancel: Don't update {reference}")
            input_box.destroy()
            settings_clicked()
            return "break"
        
        input_box = tk.Text(scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 15, height = 2, relief = "sunken")
        input_box.grid(row = row_number, column = column_number, columnspan = column_span, sticky = "nwe", padx = (0, 2), pady = (0, 0))
        input_box.focus_set()

        input_box.bind("<Return>", lambda event: submit_change(max_value))
        input_box.bind("<Escape>", lambda event: cancel())

    def update_settings_hotkey(reference, row_number, column_number, column_span = 1):
        nonlocal input_box
        print(f"Update settings string called. Reference = {reference} ({app_settings[f"{reference}"]})")
        #clear_content()
        #settings_clicked()
        if input_box:
            input_box.destroy()
            input_box = None

        def submit_change():
            print("Saving change")
            new_value = input_box.get("1.0", "end-1c")
            if len(new_value) == 1:
                try:
                    app_settings[f"{reference}"] = str(new_value)
                except:
                    print("Error: Must input a string")
                    input_box.delete("1.0", "end-1c")
                    input_box.insert("1.0", "Error. Could not read input")
                    return "break"
            else:
                input_box.delete("1.0", "end-1c")
                input_box.insert("1.0", "Error. Bad input")
                return "break"
            print(f"Changed {reference} to {app_settings[f"{reference}"]}")
            save_settings(app_settings)
            input_box.destroy()
            settings_clicked()
            return "break"
        
        def cancel():
            print(f"Cancel: Don't update {reference}")
            input_box.destroy()
            settings_clicked()
            return "break"
        
        input_box = tk.Text(scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 15, height = 2, relief = "sunken")
        input_box.grid(row = row_number, column = column_number, columnspan = column_span, sticky = "nwe", padx = (0, 2), pady = (0, 0))
        input_box.focus_set()

        input_box.bind("<Return>", lambda event: submit_change())
        input_box.bind("<Escape>", lambda event: cancel())

    def update_settings_string(reference, row_number, column_number, column_span = 1):
        nonlocal input_box
        print(f"Update settings string called. Reference = {reference} ({app_settings[f"{reference}"]})")
        #clear_content()
        #settings_clicked()
        if input_box:
            input_box.destroy()
            input_box = None

        def submit_change():
            print("Saving change")
            new_value = input_box.get("1.0", "end-1c")
            try:
                app_settings[f"{reference}"] = str(new_value)
            except:
                print("Error: Must input a string")
                input_box.delete("1.0", "end-1c")
                input_box.insert("1.0", "Error. Could not read input")
                return "break"
            print(f"Changed {reference} to {app_settings[f"{reference}"]}")
            save_settings(app_settings)
            input_box.destroy()
            settings_clicked()
            return "break"

        def cancel():
            print(f"Cancel: Don't update {reference}")
            input_box.destroy()
            settings_clicked()
            return "break"
        
        input_box = tk.Text(scrollable_frame, font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_medium, fg = widgets_color_text, width = 10, height = 2, relief = "sunken")
        input_box.grid(row = row_number, column = column_number, columnspan = column_span, sticky = "nwe", padx = (0, 2), pady = (0, 0))
        input_box.focus_set()

        input_box.bind("<Return>", lambda event: submit_change())
        input_box.bind("<Escape>", lambda event: cancel())



#OTHER FUNCTIONS
buttons = [
    ("Decks", flashcards_clicked, "Select a flashcard deck to study"),
    ("Stats", stats_clicked, "View study statistics"),
    ("Settings", settings_clicked, "Change settings")
]

def on_default(event, color_palette):
    global tooltip_tracker
    tooltip_tracker = False
    event.widget.config(cursor="arrow")
    """Reset button to default state when mouse leaves"""
    if color_palette == ("dark"):
        event.widget.configure(bg = navigation_color_buttons)
    elif color_palette == "medium_dark":
        event.widget.configure(bg = widgets_color_medium_dark)
    elif color_palette == "medium":
        event.widget.configure(bg = widgets_color_medium)
    else:
        event.widget.configure(bg = widgets_color_light)
        #global navigation_color_buttons, navigation_color_buttons_hover, navigation_color_backgrounds, navigation_color_text, widgets_color_light, widgets_color_medium, widgets_color_medium_dark, widgets_color_dark, widgets_color_text
def on_hover(event, color_palette, tooltip_send = "Click to interact"):
    global tooltip_tracker, tooltip
    tooltip_tracker = True
    tooltip = tooltip_send
    event.widget.config(cursor="hand2")
    """Handle mouse hover over button"""
    if color_palette == ("dark"):
        event.widget.configure(bg = navigation_color_buttons_hover)
    elif color_palette == "medium_dark":
        event.widget.configure(bg = widgets_color_dark)
    elif color_palette == "medium":
        event.widget.configure(bg = widgets_color_medium_dark)
    else:
        event.widget.configure(bg = widgets_color_medium)

    start_time = time.time()
    cursor_x_check = None
    cursor_y_check = None
    def update_tooltip_timer():
        nonlocal cursor_x_check, cursor_y_check, start_time
        global tooltip_tracker, tooltip_holder, tooltip
        nonlocal event
        
        #print("Timer")

        x_pos = event.widget.winfo_pointerx()  # X coordinate relative to screen
        y_pos = event.widget.winfo_pointery()  # Y coordinate relative to screen

        if cursor_x_check == x_pos and cursor_y_check == y_pos:

            elapsed = time.time() - start_time

            if elapsed >= 1 and tooltip_tracker == True:
                #print("Hello, world!")
                #x, y, _, _ = event.widget.bbox("insert")  # Get widget position
                #x += event.widget.winfo_rootx() + 75
                #y += event.widget.winfo_rooty() + 75
                
                x_pos = event.widget.winfo_pointerx()  # X coordinate relative to screen
                y_pos = event.widget.winfo_pointery()  # Y coordinate relative to screen

                cursor_x_check = x_pos
                cursor_y_check = y_pos

                if tooltip_holder == None:
                    tooltip_holder = tk.Toplevel(root, bg = navigation_color_buttons)
                    tooltip_holder.wm_overrideredirect(True)  # Remove window decorations
                    tooltip_holder.wm_geometry(f"+{x_pos + 14}+{y_pos + 10}")
                
                    label = tk.Label(tooltip_holder, text=tooltip, background=widgets_color_light, font=(app_settings['font'], app_settings['font_size']))
                    label.pack(padx = 2, pady = 2)

            root.after(25, update_tooltip_timer)
        else:
            #print("cursor moved")
            if tooltip_holder is not None:  # Check if tooltip exists
                #print("attempt to destroy tooltip")
                tooltip_holder.destroy()
                tooltip_holder = None

            cursor_x_check = x_pos
            cursor_y_check = y_pos
            start_time = time.time()

            if tooltip_tracker == True:
                root.after(25, update_tooltip_timer)
            
        if tooltip_tracker == False:
            if tooltip_holder is not None:  # Check if tooltip exists
                #print("attempt to end loop")
                tooltip_holder.destroy()
                tooltip_holder = None

            return

        
    update_tooltip_timer()
def generate_sidebar_buttons():
    # Create sidebar buttons
    color_palette = ("dark") 
    for button_text, button_function, tooltip in buttons:
        btn = tk.Button(
            sidebar, 
            text=button_text, 
            width=15, 
            height=3, 
            font=(app_settings['font'], app_settings['font_size']), 
            bg = navigation_color_buttons, 
            fg = navigation_color_text,
            command=button_function
        )
        btn.pack(pady=10, padx=10)
        
        # Bind events

        btn.bind('<Leave>', lambda event: on_default(event, color_palette))
        btn.bind('<Enter>', lambda event, tooltip_send = tooltip: on_hover(event, color_palette, tooltip_send))
generate_sidebar_buttons()

# ==== Set up start-up screen ====
content_frame.columnconfigure(0, weight = 1)
startup_box = tk.Label(content_frame, text = "Welcome to Monarch Flashcards!", relief="flat", height = 1, state="normal", justify="center", pady=4, padx=4, 
                font=(app_settings['font'], 24), bg = widgets_color_light, fg = widgets_color_text)
startup_box.grid(row = 0, column = 0, padx = 40, pady = 16)

startup_box2 = tk.Label(content_frame, text = "<----- Click on sidebar buttons to begin.", relief="flat", height = 1, state="normal", justify="center", pady=4, padx=4, 
                font=(app_settings['font'], app_settings['font_size']), bg = widgets_color_light, fg = widgets_color_text)
startup_box2.grid(row = 1, column = 0, padx = 40, pady = 16)

if os.path.exists(cover_graphic):
    img = Image.open(cover_graphic)
    img.thumbnail((512, 256))
    photo = ImageTk.PhotoImage(img)

    # Create a label to display it
    image_label = tk.Label(content_frame, image=photo, bg = widgets_color_light)
    image_label.image = photo  # Keep a reference!
    image_label.grid(row=2, column=0, sticky = "we", padx = 10, pady = (80, 4))

root.mainloop()

#def study_flashcard():